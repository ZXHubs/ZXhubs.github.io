{"pages":[{"title":"","text":"Hi 我是 ZhangX","link":"/about/index.html"}],"posts":[{"title":"Hello World","text":"欢迎👏来到这。","link":"/2022/02/19/hello-world/"},{"title":"Swift 笔记","text":"swift 笔记基础介绍常量let &amp; 变量var1234let a = 10 // 常量的值设定后不能更改var b = 0var x = 0.0, y = 0.0, z = 0.0var red, green, blue: Double // 理论上可以实际很少这么写 常量和变量名可以包含任何字符，包括一些Unicode字符。常量和变量名不能包含空格，数学符号，箭头，专用的Unicode标量值或线条和框形图字符，不能以数字开头。不能将常量更改为变量或将变量更改为常量。如果需要命名为保留的Swift关键字名称，在关键字两端加上反引号`，不建议使用保留的关键字。 使用 \\() 打印 1print(&quot;a = \\(num))&quot;) 注释123// 单行注释/* 多行注释可以嵌套 */ 分号可以写也可以不写，一般不写分号。如果要在一行上编写多个单独的语句，则需要分号。 整数Swift提供8位，16位，32位和64位形式的有符号和无符号整数。其中8位无符号整数的类型为UInt8，而32位有符号整数的类型为Int32。一般使用Int就可以了。 12let minValue = UInt8.min // 0let maxValue = UInt8.max // 255 在大多数情况下，无需选择特定大小的整数即可在代码中使用。Swift提供了额外的整数类型，Int其大小与当前平台的本机字大小相同：在32位平台上，Int与大小相同Int32；在64位平台上，Int与大小相同Int64。Swift还提供了一个无符号整数类型，UInt其大小与当前平台的本机字大小相同。 浮点值 Double 表示一个64位浮点数，精度至少为15个十进制数字 Float 表示一个32位浮点数，精度可以低至6个十进制数字类型推断当声明具有初始值的常量或变量时，swift根据类型推断来确定常量或者变量的类型：var name: String在浮点值里面默认都是Double数字1234let a = 17 // 十进制数，无前缀let b = 0b10001 // 二进制数，前缀0blet c = 0o21 // 八进制数，前缀0olet d = 0x11 // 十六进制数，前缀0x 浮点文字可以是十进制（不带前缀）或十六进制（带0x前缀）。它们的小数点两侧必须始终有一个数字（或十六进制数字）。小数浮点数也可以有一个可选的指数，用大写或小写表示e; 十六进制浮点数必须具有指数，以大写或小写表示p。对于指数为的十进制数字exp，基数乘以10^exp： 1.25e2表示1.25 x 10^2，或125.0。 1.25e-2表示1.25 x 10^-2，或0.0125。 对于指数为的十六进制数exp，将基数乘以2^exp： 0xFp2表示15 x 2^2，或60.0。 0xFp-2表示15 x 2^-2，或3.75。 123let decimal = 12.1875 // 十进制let e = 1.21875e1 // 指数let hexadecimal = 0xC.3p0 // 十六进制 数值类型转换123let twoThousand: UInt16 = 2_000let one: UInt8 = 1let twoThousandAndOne = twoThousand + UInt16(one) 类型别名类型别名为现有类型定义备用名称，可以使用typealias关键字定义类型别名。想通过上下文更合适的名称来引用现有类型时，例如使用外部源中特定大小的数据时，类型别名非常有用： 1typealias AudioSample = UInt16 定义类型别名后，可以在任何可能使用原始名称的地方使用别名： 12var maxAmplitudeFound = AudioSample.min 布尔值 Booltrue 和 false 数组 Tuples数组将多个值分组为一个复合值。数组中的值可以是任何类型，而不必彼此相同。如果请求的网页不存在，则返回状态404 Not Found 1let http404Error = (404, &quot;Not Found&quot;) 可以将数组的内容分解为单独的常量或变量，然后像往常一样访问它们： 12345let (statusCode, statusMessage) = http404Errorprint(&quot;The status code is \\(statusCode)&quot;)print(&quot;The status message is \\(statusMessage)&quot;) 如果只需要一些数组的值，则在分解数组时，请用下划线_忽略该数组的某些部分： 123let (justTheStatusCode, _) = http404Errorprint(&quot;The status code is \\(justTheStatusCode)&quot;) 或者，使用从零开始的索引号访问数组中的各个元素值： 1234print(&quot;The status code is \\(http404Error.0)&quot;)print(&quot;The status message is \\(http404Error.1)&quot;) 定义数组时，可以命名数组中的各个元素： 1let http200Status = (statusCode: 200, description: &quot;OK&quot;) 如果在数组中命名元素，则可以使用元素名称来访问这些元素的值： 1234print(&quot;The status code is \\(http200Status.statusCode)&quot;)// Prints &quot;The status code is 200&quot;print(&quot;The status message is \\(http200Status.description)&quot;)// Prints &quot;The status message is OK&quot; 具有多个返回值的函数使用数组特别合适。数组对于简单的一组相关值很有用。它们不适合创建复杂的数据结构。如果数据结构可能更复杂，则将其建模为类或结构，而不是数组。 OptionalsOptionals 表示要么有一个值并且可访问该值，或者为nil。以下示例使用初始化程序尝试将 String转换为Int，由于初始化程序可能失败，因此它返回一个optional Int而不是一个Int。 123let possibleNumber = &quot;123&quot;let convertedNumber = Int(possibleNumber) 如果定义一个可选变量而不提供默认值，则该变量将自动nil设置为： 123var surveyAnswer: String?surveyAnswer = nil // 也可以给optional赋值为nil 1. 可选值的强制展开一旦确定可选选项确实包含一个值，就可以在可选名称的末尾添加一个感叹号!来访问其基础值。 123if convertedNumber != nil { print(&quot;convertedNumber has an integer value of \\(convertedNumber!).&quot;)} 2. Optional 可选 12345678910if let constantName = someOptional { statements}if let actualNumber = Int(possibleNumber) { print(&quot;The string \\&quot;\\(possibleNumber)\\&quot; has an integer value of \\(actualNumber)&quot;)} else { print(&quot;The string \\&quot;\\(possibleNumber)\\&quot; could not be converted to an integer&quot;)} 字符串Strings多行字符串文字用三引号 “””两个”””之间的字符串都作为多行字符串的值，如果仅想在代码里换行是代码易读，可以在换行符前添加反斜杠转义 转义字符串\\0（空字符）\\（反斜杠）\\t（水平制表符）\\n（换行符）\\r（回车）&quot;（双引号）'（单引号）任意的Unicode标值，写为\\u{n}，其中n是一个1-8位十六进制数 1234567891011let wiseWords = &quot;\\&quot;Imagination is more important than knowledge\\&quot; - Einstein&quot;let dollarSign = &quot;\\u{24}&quot; // $, Unicode scalar U+0024let blackHeart = &quot;\\u{2665}&quot; // ♥, Unicode scalar U+2665let sparklingHeart = &quot;\\u{1F496}&quot; // 💖, Unicode scalar U+1F496//因为多行字符串文字使用三个双引号而不是一个双引号，可以在多行字符串文字中包含一个双引号而不进行转义。let threeDoubleQuotationMarks = &quot;&quot;&quot;Escaping the first quotation mark \\&quot;&quot;&quot;Escaping all three quotation marks \\&quot;\\&quot;\\&quot;&quot;&quot;&quot; 初始化字符串123var emptyString = &quot;&quot; // 空var anotherEmptyString = String() // 初始化 访问和修改String1234567891011121314151617181920let greeting = &quot;Guten Tag!&quot;greeting[greeting.startIndex]// Ggreeting[greeting.index(before: greeting.endIndex)]// !greeting[greeting.index(after: greeting.startIndex)]// ulet index = greeting.index(greeting.startIndex, offsetBy: 7)greeting[index]// agreeting[greeting.endIndex] // Errorgreeting.index(after: greeting.endIndex) // Errorfor index in greeting.indices { print(&quot;\\(greeting[index]) &quot;, terminator: &quot;&quot;)} 子串12345let greeting = &quot;Hello, world!&quot;let index = greeting.firstIndex(of: &quot;,&quot;) ?? greeting.endIndexlet beginning = greeting[..&lt;index]let newString = String(beginning) greeting是一个字符串，具有一个存储区域，用于存储组成该字符串的字符。因为beginning是的子字符串greeting，所以它重复使用了所greeting使用的内存。相反，newString是一个字符串-从子字符串创建它时，它具有自己的存储空间。准备长时间存储结果时，可以将子字符串转换为字符串 比较字符串可以用 == 或者 != 12345let str = &quot;HelloWorld&quot;let str1 = &quot;HelloWorld&quot;if str == str1 { print(&quot;相等&quot;)} 集合三种collection： array有序集合, set唯一值的无序集合, dictionary键-值对关联的无序集合。 Array1234567891011var arr = Array&lt;Int&gt; // 空数组，两种方式，一般采用[]var someInts = [Int]() // 简写someInts.append(3) someInts = [] var threeDoubles = Array(repeating: 0.0, count: 3)var anotherThreeDoubles = Array(repeating: 2.5, count: 3)var sixDoubles = threeDoubles + anotherThreeDoubles 增删改查 12345678910111213141516171819202122232425262728293031323334353637383940var shoppingList: [String] = [&quot;Eggs&quot;, &quot;Milk&quot;]var shoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;] // 类型推断print(&quot;The shopping list contains \\(shoppingList.count) items.&quot;)if shoppingList.isEmpty { print(&quot;The shopping list is empty.&quot;)} else { print(&quot;The shopping list is not empty.&quot;)}shoppingList.append(&quot;Flour&quot;)shoppingList += [&quot;Baking Powder&quot;]shoppingList += [&quot;Chocolate Spread&quot;, &quot;Cheese&quot;, &quot;Butter&quot;]var firstItem = shoppingList[0]shoppingList[0] = &quot;Six eggs&quot;shoppingList[4...6] = [&quot;Bananas&quot;, &quot;Apples&quot;]// 将索引[4,6]的元素换成[&quot;Bananas&quot;, &quot;Apples&quot;] // insert和remove操作后，其他元素顺移shoppingList.insert(&quot;Maple Syrup&quot;, at: 0)// 索引0位置插入为&quot;Maple Syrup&quot;let mapleSyrup = shoppingList.remove(at: 0)// 删除索引0位置的元素，并且返回该位置元素的值let apples = shoppingList.removeLast() //避免查询.count检查是否越界for item in shoppingList { print(item)}for (index, value) in shoppingList.enumerated() { print(&quot;Item \\(index + 1): \\(value)&quot;)} Set类型必须是可哈希的才能存储在Set中 123var letters = Set&lt;Character&gt;() // Set没有简写letters.insert(&quot;a&quot;) letters = [] 增删改查 12345678910111213141516171819202122232425262728293031323334353637383940var favoriteGenres: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]var favoriteGenres: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;] //类型推断print(&quot;I have \\(favoriteGenres.count) favorite music genres.&quot;)if favoriteGenres.isEmpty { print(&quot;As far as music goes, I'm not picky.&quot;)} else { print(&quot;I have particular music preferences.&quot;)}favoriteGenres.insert(&quot;Jazz&quot;)// .removeAll()删除全部元素if let removedGenre = favoriteGenres.remove(&quot;Rock&quot;) { print(&quot;\\(removedGenre)? I'm over it.&quot;)} else { print(&quot;I never much cared for that.&quot;)}if favoriteGenres.contains(&quot;Funk&quot;) { print(&quot;I get up on the good foot.&quot;)} else { print(&quot;It's too funky in here.&quot;)}for genre in favoriteGenres { print(&quot;\\(genre)&quot;)}for genre in favoriteGenres.sorted() { // 按&lt;的顺序返回 print(&quot;\\(genre)&quot;)} intersection(_:)方法创建仅具有两个集合共有的值的新集合。 symmetricDifference(_:)方法创建一个新集合，其中两个集合中都有一个值，但不能同时包含两个集合中的值。 union(_:)方法创建一个包含两个集合中所有值的新集合。 subtracting(_:)方法创建一个新集合，其值不在指定集合中。 ==确定两组是否包含所有相同的值。 isSubset(of:)方法确定集合中的所有值是否都包含在指定集合中。 isSuperset(of:)方法确定集合是否包含指定集合中的所有值。 isStrictSubset(of:)或isStrictSuperset(of:)方法确定集合是子集还是超集，但不等于指定的集合。 isDisjoint(with:)方法确定两个集合是否没有共同的值。 Dictionary字典Key类型必须符合Hashable协议 1234567var dic = Dictionary&lt;Key, Value&gt;var namesOfIntegers = [Int: String]() // 简写namesOfIntegers[16] = &quot;sixteen&quot;namesOfIntegers = [:] 增删改查 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var airports: [String: String] = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]var airports = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]// 当key和value是同一类型的时候，swift可以进行类型推断print(&quot;The airports dictionary contains \\(airports.count) items.&quot;)if airports.isEmpty { print(&quot;The airports dictionary is empty.&quot;)} else { print(&quot;The airports dictionary is not empty.&quot;)}airports[&quot;LHR&quot;] = &quot;London&quot;airports[&quot;LHR&quot;] = &quot;London Heathrow&quot;if let oldValue = airports.updateValue(&quot;Dublin Airport&quot;, forKey: &quot;DUB&quot;) { print(&quot;The old value for DUB was \\(oldValue).&quot;)}// updateValue(_:forKey:)方法返回字典值类型的可选值。if let airportName = airports[&quot;DUB&quot;] { print(&quot;The name of the airport is \\(airportName).&quot;)} else { print(&quot;That airport is not in the airports dictionary.&quot;)}airports[&quot;APL&quot;] = &quot;Apple International&quot;airports[&quot;APL&quot;] = nilif let removedValue = airports.removeValue(forKey: &quot;DUB&quot;) { print(&quot;The removed airport's name is \\(removedValue).&quot;)} else { print(&quot;The airports dictionary does not contain a value for DUB.&quot;)}for (airportCode, airportName) in airports { print(&quot;\\(airportCode): \\(airportName)&quot;)}for airportCode in airports.keys { print(&quot;Airport code: \\(airportCode)&quot;)}for airportName in airports.values { print(&quot;Airport name: \\(airportName)&quot;)} Swift的Dictionary类型没有定义的顺序。要以特定顺序遍历字典的键或值，可以在keys或values属性上使用sorted()。 控制流for in 循环1234567891011for index in 1...5 { print(&quot;\\(index) times 5 is \\(index * 5)&quot;)}// index是一个常数无需声明let base = 3let power = 10var answer = 1for _ in 1...power { answer *= base}// 如果不需要索引值，怎可以使用 下划线_ 代替 123456789101112131415let minutes = 60for tickMark in 0..&lt;minutes {}let minuteInterval = 5for tickMark in stride(from: 0, to: minutes, by: minuteInterval) { }let hours = 12let hourInterval = 3for tickMark in stride(from: 3, through: hours, by: hourInterval) { } While 循环 while 每次循环执行时都会评估其条件。 repeat- while在每次循环结束时评估其条件。在考虑循环条件之前，会先执行一次循环循环。然后，它将继续重复循环，直到条件为false。类似于 do - while 1234567while condition { statements}repeat { statements} while condition 条件语句if多个判断条件可以用逗号连接 switchbreak在Swift中不是必需的，但是可以使用break语句来匹配和忽略特定的情况，或者在该情况完成执行之前中断匹配的情况。每个case都必须包含一个可执行语句，一个case两种value用逗号隔开 123456789101112131415161718192021222324252627282930switch some value to consider {case value 1: respond to value 1case value 2, value 3: respond to value 2 or 3default: otherwise, do something else}//间隔匹配let approximateCount = 62let countedThings = &quot;moons orbiting Saturn&quot;let naturalCount: Stringswitch approximateCount {case 0: naturalCount = &quot;no&quot;case 1..&lt;5: naturalCount = &quot;a few&quot;case 5..&lt;12: naturalCount = &quot;several&quot;case 12..&lt;100: naturalCount = &quot;dozens of&quot;case 100..&lt;1000: naturalCount = &quot;hundreds of&quot;default: naturalCount = &quot;many&quot;}print(&quot;There are \\(naturalCount) \\(countedThings).&quot;) 1234567891011121314let somePoint = (1, 1)switch somePoint {case (0, 0): print(&quot;\\(somePoint) is at the origin&quot;)case (_, 0): print(&quot;\\(somePoint) is on the x-axis&quot;)case (0, _): print(&quot;\\(somePoint) is on the y-axis&quot;)case (-2...2, -2...2): print(&quot;\\(somePoint) is inside the box&quot;)default: print(&quot;\\(somePoint) is outside of the box&quot;)} (0，0）可以匹配所有四种情况。但是，如果可能有多个匹配项，则始终使用第一个匹配情况，所有其他匹配情况都将被忽略。 函数Function只用return一行编写的任何函数都可以省略return。 123456789101112131415161718// 没有参数func sayHelloWorld() -&gt; String { return &quot;hello, world&quot;}// 多个参数func greet(person: String, alreadyGreeted: Bool) -&gt; String { if alreadyGreeted { return greetAgain(person: person) } else { return greet(person: person) }}// 没有返回值func greet(person: String) { print(&quot;Hello, \\(person)!&quot;)} 12345678910func printAndCount(string: String) -&gt; Int { print(string) return string.count}func printWithoutCounting(string: String) { let _ = printAndCount(string: string)}printAndCount(string: &quot;hello, world&quot;)printWithoutCounting(string: &quot;hello, world&quot;) 第一个函数printAndCount(string:)打印一个字符串，然后将其字符计数返回为Int。第二个函数printWithoutCounting(string:)调用第一个函数，但忽略其返回值。当调用第二个函数时，第一个函数仍会打印该消息，但是不使用返回的值。 具有多个返回值的函数可以使用数组类型作为函数的返回类型，以将多个值作为一个复合返回值的一部分返回。 123456789101112131415func minMax(array: [Int]) -&gt; (min: Int, max: Int) { var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] { if value &lt; currentMin { currentMin = value } else if value &gt; currentMax { currentMax = value } } return (currentMin, currentMax)}let bounds = minMax(array: [8, -6, 2, 109, 3, 71])print(&quot;min is \\(bounds.min) and max is \\(bounds.max)&quot;) 在从函数返回数组时不必命名数组的成员，因为它们的名称已作为函数返回类型的一部分指定。 返回Optional123456789101112131415161718func minMax(array: [Int]) -&gt; (min: Int, max: Int)? { if array.isEmpty { return nil } var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] { if value &lt; currentMin { currentMin = value } else if value &gt; currentMax { currentMax = value } } return (currentMin, currentMax)}if let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) { print(&quot;min is \\(bounds.min) and max is \\(bounds.max)&quot;)} 函数类型由函数的参数类型和返回类型组成，如(Int, Int) -&gt; Int 1234// () -&gt; Voidfunc printHelloWorld() { print(&quot;hello, world&quot;)} 使用函数类型可以将常量或变量定义为函数类型，然后为该变量分配适当的函数： 1var mathFunction: (Int, Int) -&gt; Int = addTwoInts “定义一个名为mathFunction的变量，其类型为一个具有两个Int值并返回Int值的函数。” 设置这个变量来表示函数addTwoInts。” 1234print(&quot;Result: \\(mathFunction(2, 3))&quot;) // Prints &quot;Result: 5&quot;let anotherMathFunction = addTwoInts // 类型推断 Function Types作为另一个函数的参数类型12345func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) { print(&quot;Result: \\(mathFunction(a, b))&quot;)}printMathResult(addTwoInts, 3, 5) 定义了一个名为printMathResult(::_:)的函数，该函数具有三个参数。第一个参数名为mathFunction，类型为(Int, Int) -&gt; Int。第二个和第三个参数分别名为a和b，并且均为type Int。 Function Types作为返回类型123456789101112131415161718192021func stepForward(_ input: Int) -&gt; Int { return input + 1}func stepBackward(_ input: Int) -&gt; Int { return input - 1}func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int { return backward ? stepBackward : stepForward}var currentValue = 3let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)print(&quot;Counting to zero:&quot;)while currentValue != 0 { print(&quot;\\(currentValue)... &quot;) currentValue = moveNearerToZero(currentValue)}print(&quot;zero!&quot;) 嵌套函数12345678910111213func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int { func stepForward(input: Int) -&gt; Int { return input + 1 } func stepBackward(input: Int) -&gt; Int { return input - 1 } return backward ? stepBackward : stepForward}var currentValue = -4let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)while currentValue != 0 { print(&quot;\\(currentValue)... &quot;) currentValue = moveNearerToZero(currentValue)}print(&quot;zero!&quot;) 枚举语法1234567891011121314151617181920enum CompassPoint { case north case south case east case west}var directionToHead = CompassPoint.westdirectionToHead = .east // 类型推断directionToHead = .southswitch directionToHead {case .north: print(&quot;Lots of planets have a north&quot;)case .south: print(&quot;Watch out for penguins&quot;)case .east: print(&quot;Where the sun rises&quot;)case .west: print(&quot;Where the skies are blue&quot;)} 遍历枚举1234567891011enum Beverage: CaseIterable { case coffee, tea, juice}let numberOfChoices = Beverage.allCases.countprint(&quot;\\(numberOfChoices) beverages available&quot;)for beverage in Beverage.allCases { print(beverage)} 结构体和类Swift不需要为自定义结构和类创建单独的接口和实现文件，可以在单个文件中定义结构或类，并且该类或结构的外部接口会自动提供给其他代码使用。 struct和class的共同点和区别class具有struct没有的其他功能： 继承使一个类可以继承另一个类的特征。 通过类型转换，可以在运行时检查和解释类实例的类型。 反初始化程序使类的实例可以释放其已分配的所有资源。 引用计数允许对一个类实例进行多个引用。 12345678910111213141516171819202122232425struct Resolution { var width = 0 var height = 0}class VideoMode { var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String?}// 创建实例（对象）let someResolution = Resolution()let someVideoMode = VideoMode()// 访问属性print(&quot;The width of someResolution is \\(someResolution.width)&quot;)print(&quot;The width of someVideoMode is \\(someVideoMode.resolution.width)&quot;)someVideoMode.resolution.width = 1280print(&quot;The width of someVideoMode is now \\(someVideoMode.resolution.width)&quot;)// struct具有Initializers，class需要initlet vga = Resolution(width: 640, height: 480) struct和enum是值类型Swift中的所有基本类型（整数，浮点数，布尔值，字符串，数组和字典）都是值类型，所有结struct和enum都是值类型。。 class是引用类型与值类型不同，将引用类型分配给var或let或将其传递给函数时，不会复制引用类型，而是都是同一个实例的引用。 可以通过 === 或者 !== 比较两个是否引用相同的实例 === 表示var或者let都引用同一个实例，而==表示两个实例的值相等 123if tenEighty === alsoTenEighty { print(&quot;tenEighty and alsoTenEighty refer to the same VideoMode instance.&quot;)}","link":"/2022/02/19/swift/"},{"title":"咖啡","text":"咖啡的小知识原材料：咖啡从树上结果，生的状态一般叫绿咖啡Green coffee咖啡两大类：Arabica阿拉比卡和Robusta罗布斯塔。前者比后者更优质咖啡因的含量和风味不同。一般Robusta豆的咖啡因比Arabica豆要高。Robusta主要产地是东半球越南、非洲。Arabica糖和脂多主要产地牙买加、夏威夷。品牌：蓝山、曼特宁、科纳。咖啡树热带植物煮的咖啡brewed coffeelight/blonde轻度烘焙；medium中度烘焙；dark roast重度烘焙酸涩感：轻度&gt;中度&gt;重度冲煮专业名词都为萃取浸泡式brewed意式浓缩espresso【可以搭配奶、巧克力酱】拿铁、摩卡、卡布奇诺","link":"/2022/02/19/%E5%92%96%E5%95%A1/"},{"title":"搭建博客","text":"利用 Hexo + GitHub(Gitee) Pages 搭建个人博客序 文章从两个部分介绍 Hexo 和 GitHub Pages 结合，快速、便捷的搭建出博客，且无流量限制，属于自己的个人博客。续写你自己的技术、感受等任何类型的文章。 GitHub(Gitee) Pages步骤一、如果没有 GitHub 或 Gitee 账户先注册一个。然后新建一个仓库。在 GitHub 下仓库名要求格式：xxx.github.io 的形式。步骤二、勾选 README。步骤三、点击 Create repository。 对于 Gitee 来说，仓库必须有 index.html 才可以正常访问。步骤一、新建一个仓库。步骤二、新建一个文件 index.html 提交到仓库步骤三、选择 “服务 - Pages 服务”（注意使用必须要求实名认证否则无法使用，不想实名认证建议使用 GitHub）步骤四、选择部署分支点击启动。 Hexo https://hexo.io/zh-cn/ 这是 Hexo 中文官方网站https://git-scm.com 这是 Git 官方网站https://nodejs.org/zh-cn/ 这是 Node.js 官方网站 步骤一、在本地创建一个存放博客的文件夹。步骤二、确保本机已经安装好了 Node.js 和 Git。步骤三、通过终端（Mac）或 Windows 下的命令行工具执行下列命令安装 Hexo。不要复制 $ 符号。假设文件夹在桌面上名为：zxhusb。 12$ cd /Desktop/zxhubs$ npm install -g hexo-cli 步骤四、在zxhubs文件夹目录下执行，如果没有执行 cd zxhusb。 123$ hexo init zxhusb$ npm install$ hexo server 步骤五、打开浏览器输入 localhost:4000 即可看到对应 Hexo 的默认 landscape 主题。如果对默认的不满意，（绝大多数人都会修改主题）在 Hexo 主题 中找到自己喜欢的主题。如果需要关闭本地服务器在命令行直接按 control + C 即可关闭。步骤六、更换主题，在 zxhubs 的目录下执行，下面命令是举例说明。 1$ git clone https://github.com/probberechts/cactus-dark 在 zxhubs 编辑 _config.yml，修改 theme，为主题的名字。 12theme: cactus-dark 步骤七、上传到 GitHub 或 Gitee 上，继续编辑 _config.yml。 123456deploy: type: git repository: # 此处改为你自己GitHub Pages 或者 Gitee Pages 地址 branch:main #注意以前用的 GitHub 已将 master 改成了 mian，对于 Gitee 还是 master 这样大家都可以在网上浏览了你的网页了。步骤八、添加或修改博客的内容 1hexo new 此处替换为你的文章名字支持中英文 步骤九、完成文章的撰写后，执行下列命令，生成静态网页。 1hexo g 步骤十、上传到网页上执行 1hexo deploy 这样即可在网页中看到修改的内容了，如果不想使用 xxx.github.io或xxx.gitee.io的域名，可以自己去备案购买申请一个域名，修改为自己的域名。 跋 希望上述教程能够协助大家完成自己博客的搭建，这将会是一件有趣事情。能够提高你自己的动手能力和解决问题的能力，在搭建和写作过程中遇到的问题可以慢慢探索。","link":"/2022/02/20/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"title":"如何运行 GitHub 上的 iOS app","text":"步骤一、clone 源码之后，在你的 Mac 上安装 CocoaPods。 步骤二、打开 终端，切换到工程文件的目录下。比如你的工程文件下载到了 Mac 的桌面上，在 终端 app 中输入 cd 切换到文件目录下。 步骤三、输入 pod install 安装工程所依赖的库。显示如下即安装成功。步骤四、在 Xcode 中打开运行本工程文件，请注意⚠️打开的是 .xcworkspace 并非是 .xcodeproj，请务必注意后缀。 在上述指南中可能会遇到的一些疑惑。 Q：CocoaPods 是什么？A：CocoaPods 是 macOS 和 iOS 平台非常流行的包管理工具，用来帮助我们管理第三方依赖库的工具。通过调用第三方库，可以用于拓展软件的功能。 Q：为什么需要 CocoaPods？A：在实际开发过程中避免不了去使用第三方的库，所以会使用到 CocoaPods。pod 是由 ruby 语言编写的，是记录引用库的名称，执行 pod install 即在把远程仓库下载至本地。 Q：在使用 pod install 命令时速度过慢？A：解决方案之一可以采取换源的方式。输入 gem sources 能够查看当前源。输入 gem sources --add https://gems.ruby-china.com/ 删除之前的源 gem sources -r https://rubygems.org/ Q：在使用 Podfile 文件是什么？A：用于描述一个或多个 Xcode Project 中各个 Targets 之间的依赖关系 Q：在使用 Lockfile 文件是什么？A：用于记录最后一次 CocoaPods 所安装的 Pod 依赖库版本的信息快照。生成的 Podfile.lock。在 pod install 过程，Podfile 会结合它来确认最终所安装的 Pod 版本。 Q：xcworkspace 和 xcodeproj 的区别？A：xcodeproj bundle 内包含 project.workspace。而当我们通过 pod install 命令添加 Pod 依赖后，Xcode 工程目录下会多出 .workspace，它是 Xcodeproj 替我们生成的，用于管理当前的 .project 与 Pods.pbxproj。","link":"/2022/02/22/%E5%A6%82%E4%BD%95%E8%B7%91GitHub%E4%B8%8A%E7%9A%84iOSapp/"},{"title":"设计模式 MVC 和 MVVM","text":"MVCM 是数据模型 Model，负责处理数据，以及数据改变时发出通知。（Notification、KVO），Model 和 View 不能直接进行通信，这样会违背 MVC 设计模式。 V 是视图 View，用来展示界面，和用户进行交互，为了解耦合一般不会直接持有或者操作数据层中的数据模型（可以通过 target-action、delegate、block 等方式解耦）。 C 是控制器 Controller 用来调节 Model 和 View 之间的交互，可以直接与 Model 还有 View 进行通信，操作 Model 进行数据更新，刷新 View。 MVC如图所示 优点：View、Model 低耦合、高复用、容易维护。缺点：Controller 的代码过于臃肿，如果 View 与 Model 直接交互会导致 View 和 Model 之间的耦合性增大，网络逻辑会加重 Controller 的臃肿。 1、 Controller 和 View 之间可以通信，Controllor 通过 outlet(输出口)控制 View，View 可以通过 target-action、delegate 或者 data source(想想UITableVeiwDatasource)来和 Controller 通信； 2、 Controller 在接收到 View 传过来的交互事件(View就是完成让人和程序的交互的呀，比如按下按钮)之后，经过一些判断和处理，把需要 Model 处理的事件递交给 Model 处理(比如刚才的例子中的保存到数据库)，Controller 对 Model 使用的是 API； 3、 Model 在处理完数据之后，如果有需要，会通过 Notification 或者 KVO 的方式告知 Controller，事件已经处理完，Controller 再经过判断和处理之后，考虑下一步要怎么办(是默默无闻的在后台操作，还是需要更新 View，这得看 Controller 的“脸色”行事)。这里的无线天线很有意思，Model 只负责发送通知，具体谁接收这个通知并处理它，Model 并不关心，这一点非常重要，是理解 Notification 模式的关键。 4、 Model 和 View 之间不直接通信！ View 通过 target-action 模式向 Controller 传递消息，Controller 通过 API 调用 Model 里面的方法来处理从 View 那接收到的消息；Model 处理完数据之后，通过 Notification 模式向 Controller 传递一个消息，最终 Controller 通过一个方法(即 Notification 的接收方法)弹出来一个对话框显示 Model 已经处理完成。 MVVMMVVM 衍生于 MVC，是 MVC 的一种演进，促进了 UI 代码和业务逻辑的分离，抽取 Controller 中的展示逻辑放到 ViewModel 中。 M：数据模型 Model，负责处理数据，以及数据改变时发出通知。 V：是 View 和 Controller 联系到一起，视为一个组件 View。View 和 Controller 都不直接引用模型 Model，可以引用视图模型 ViewModel。ViewController 尽量不涉及业务逻辑，让 ViewModel 做这些事情。ViewController 属于中间人，负责接收 View 的事件、调用 ViewModel 的方法、响应 ViewModel 的变化。 VM：ViewModel 负责封装业务逻辑、网络处理和数据缓存。使用 ViewModel 会轻微增加代码量，但是总体上减少了代码的复杂性。ViewModel 之间可以有依赖。 注意事项：View 引用 ViewModel，但是反过来不行，因为如果 VM 跟 V 产生了耦合，不方便复用。即不要在 ViewModel 中引用 UIKit，任何视图本身的引用都不应该放在 ViewModel 中。ViewModel 可以引用 Model，但反过来不行。 优点：低耦合、可复用、数据流向清晰，而且兼容 MVC，便于代码的移植，并且 ViewModel 可以拆除来独立开发方便测试。缺点：类会增多，ViewModel 会越来越庞大，调用复杂度增加、双向绑定数据会导致问题调试变得困难。 总结MVVM 其实是 MVC 的变种。MVVM 只是帮 MVC 中的 Controller 瘦身，把一些逻辑代码和网络请求分离出去。不让 Controller 处理更多的东西，不会变得臃肿，MVVM 和 MVC 可以根据实际需求进行灵活选择。 MVVM 在使用当中，通常还会利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。OC中可以用 RAC 函数响应式框架来实现响应式编程。","link":"/2022/02/23/MVC%E5%92%8CMVVM/"},{"title":"iOS 面试题","text":"TCP 为什么要三次握手，四次挥手？为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误，假设这是一个早已失效的报文段。 但是服务器使用到此失效的连接请求报文段后，就误认为客户端再次发出的一个新的连接请求。于是就向客户端发出确认报文段，同意建立连接。 假设不采用三次握手，那么只要服务器发出确认，新的连接就建立了。 由于客户端没有发出建立连接的请求，因此不会理睬服务器的确认，也不会向服务器发送数据，但是服务器却以为新的运输连接已经建立，并一直等待客户端发来数据，这样服务器的很多资源就会被浪费掉。 四次挥手主要是：因为 TCP 是全双工通信，在接收到客户端的关闭请求时，还可能在向客户端发送数据，因此不能回应关闭链接的请求时，同时发送关闭链接的请求。 HTTP 和 HTTPS 的区别HTTP 是明文传输，数据都是为加密的，安全性较差。HTTPS（SSL+HTTP）数据传输过程是加密的，安全性较高。 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构）申请证书，一般免费证书少，因而需要一定费用。 HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS 除了 TCP 的三个包，还要加上 SSL 握手需要的 9 个包，一共是 12 个包。 HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443. HTTPS 就是建构在 SSL/TLS 之上的 HTTP 协议，所以，HTTPS 比 HTTP 更加消耗服务器资源。 成员变量和属性的区别以及不同关键字的作用成员变量：默认修饰符是 protected，不会自动生成 set 和 get 方法，需要手动实现，不能使用点语法调用，因为没有 set 和get 方法，只能使用-&gt;。 属性：默认会生成带下划线的成员变量和 setter/getter 方法，可以使用点语法调用，实际上调用的是 set 和 get 方法。⚠️注意：分类中添加的属性是不会自动生成 setter/getter 方法，必须手动添加。 实例变量：class 类进行实例化出来的对象为实例对象。 关键字作用：public 声明公共实例变量，在任何地方都能直接访问对象的成员变量。private 声明私有实例变量，只能在当前类对象方法中直接访问，子类要访问需要调用父类的 set/get方法。 private(set)。protected 可以在当前类及其子类对象方法中直接访问（系统默认）。package 在同一个包下就可以直接访问，诸如同一个框架下。property 声明属性 多线程原理与生命周期对于单核 CPU，同一时间，CPU 只能处理一条线程，即只有一条线程在工作，iOS 中的多线程同时执行的本质是 CPU 在多个任务直接进行快速的切换，由于 CPU 调度线程的时间足够快，就造成多线程的“同时”执行的效果。其中，切换的时间间隔就是时间片。对于多核 CPU，有意义的是并发。 1、新建状态用 new 关键字建立一个线程后，该线程对象就处于新建状态。处于新生状态的线程有自己的内存空间，通过调用 start() 方法进入就绪状态。 2、就绪状态处于就绪状态线程具备了运行条件，但还没分配到 CPU，处于线程就绪队列，等待系统为其分配到 CPU。当系统选定一个等待执行的线程后，它就会从就绪状态进入运行状态，称为“CPU 调度”。 3、运行状态在运行状态的线程执行自己的 run 方法中，直到等待某资源而阻塞或完成任务而死亡。如果在给定时间片内没有执行结束，就会被系统给换下来回到就绪状态。 4、阻塞状态处于运行状态的线程在某些情况下，如执行了 sleep 方法，或等待 I/O 设备等资源，将让出 CPU 并暂时停止自己运行，进入阻塞状态。在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的 I/O 设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续执行。 5、死亡状态线程生命周期中的最后一个阶段。线程死亡的原因有三个，第一个是正常运行的线程完成了它的全部工作；第二个是线程被强制性地终止，如：通过 exit 方法来终止一个线程；第三个是线程抛出未捕获的异常。","link":"/2022/02/23/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"iOS设计模式","text":"iOS 开发中一些设计模式创建型模式 单例模式在整个应用程序中，共享一份资源。保证在程序运行过程中，一个类只有一个实例，而且在该实例只提供一个全局访问点供外界访问，从而方便控制实例个数，节约系统资源。 优点：提供了对唯一实例的受控访问、可扩展、避免频繁创建销毁对象影响性能。 缺点：延长了生命周期，一直存在占用内存。如果两个单例循环依赖会造成死锁，所以尽量不去产生单立间的依赖关系。 工厂方法模式通过类继承创建抽象产品，创建一种产品，子类化创建者并重载工厂方法以创建新产品。 抽象工厂模式通过对象组合创建抽象产品，可以创建多系列产品，必须修改父类的接口才能支持新的产品。 结构型模式 代理模式代理用来处理事件的监听和参数传递。required 修饰必须实现这个协议方法，optional 修饰可选实现。使用方法时最好先判断方法是否实现 respondsToSelector: ，避免找不到方法而崩溃。 装饰模式在不比改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。诸如：分类。 享元模式使用共享物件，减少同一类对象大量创建。如：UITableviewCell 复用。 行为型模式观察者模式其本质上是一种发布-订阅模型，用来消除具有不同行为的对象之间的耦合，通过这一模式，不同对象可以协同工作。诸如：KVO。 命令模式是一种将方法调用封装为对象的设计模式，在 iOS 中具体实现为 NSInvocation。","link":"/2022/02/24/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"搬家清单","text":"搬家全流程 MARK 找房 弄清需求，找房，砍价，签约，定搬家日期，定下一个给新家买新东西的预算（不然会很没有概念毫无节制的买买买） 搬家前准备 1 基础清洁/深度清洁 清掉新家用不掉的东西 做新家清洁（先上到下，先天花板再地面） 容易忽视的重点：插座消毒，空调遥控器消毒，门把手消毒（最容易藏细菌但是最容易被忽略的角落） 换掉皮肤直接接触的东西：马桶盖等 找人洗空调洗洗衣机 地板使用消毒水清洁 检查新家各个角落，特别是柜子角落和抽屉等，是否有蟑螂，进行消杀步骤。蟑螂药蟑螂屋都可。 搬家前准备 2 1、旧家断舍离 搬家前先做断舍离，已经坏了但是感觉还用得上东西这个时候就下决心丢掉吧，去了新家大概率也不会用啦。搬过去再丢不仅麻烦还增加打包和后续归位的工作。 闲置的电器挂闲鱼 不穿的衣服去闲鱼旧衣回收/飞蚂蚁等 看完不再需要的书放多抓鱼等 2、旧家不再采买 定下搬家时间后，开始适当进行不再采买规则，特别是厨房这边，先消耗掉现有的食物干货米面等等。 清理冰箱，记下需要早点消耗掉冷冻品等，不要买新的冻品。方便后续搬家。 3、打包前的准备 开始积累快递大箱子和快递里的防震膜了，积累到打包的时候用。 搬家工具购买（按实际情况，按需选择） 工业保鲜膜：包裹物品用-非常好用，搬家必备 气泡膜：打包易碎品用 透明大胶带：封箱用，也用在保鲜膜裹完之后不太那么结实的物品上，如果用到的纸箱很多可以再买一个切割器。 黑色大垃圾袋：买结实一点的，装重量轻体积大的东西（棉被，玩偶），后续还可以当垃圾袋再使用。 编织袋：买结实一点的，装衣服用，装包和鞋子。 纸箱：大多是厨房用，装易碎品，可以先收集自己快递的，或者去超市问老板买几个。不要买太大，难搬运。 透明细胶带：我们打包大植物辅助用的，没有植物可以不买。 不要的杂志/书：作用类似气泡膜防碎膜，塞缝隙边角等，废物利用。 搬家打包环节 我们的打包原则： 原样打包，减少后续归位和安装工作，比如衣服和衣架一起包。比如厨房抽屉、收纳盒 小件易碎用纸箱，大件较轻用编织袋。 同类形状合并包，比如长杠杠，比如装饰画。 同类形状套着包，比如厨房的大盆，比如烤盘 塞满缝隙基本不会错，不管是箱子还是抽屉等。 不同形状单个包再整体包 为方便搬运考虑，可以适当 自制 提手 搬家打包场景：厨房 易碎品 + 杂物较多，打包工具：用到箱子，气泡膜，保鲜膜，打包动作：包起来，叠着放，塞缝隙。 杯子，用气泡膜单个包，箱子先铺一层气泡膜，依次放进去杯子，尽量挤到刚刚好，不留缝隙。 盘子，箱子还是用气泡膜铺底，盘子是叠放的，气泡膜剪成正方形，放盘子中间隔着，空余缝隙再包好其他小东西放进去，最后的小缝隙撕纸张揉成团塞进去，尽量做到不留缝隙再封箱。 其他大盆大锅，叠着放，再统一用保鲜膜缠起来，保鲜膜自带粘性，不用胶带也可以包得很结实。 收纳盒，小的叠大的，空余空间再放一些不易碎的东西。 杂物抽屉，里面的东西保持原样，往里面塞纸团防止搬运震动，再东西+抽屉一起保鲜膜包，把缝隙塞满，基本不会有太大问题。 其他杂物，不同形状的东西单个包，再整体包。 全部打包好的箱子可以随手记一下编号这样（厨房1，厨房2，厨房3），我们是用手机拍了箱子内容物，再在照片标注物品，后续用图片来查找。 搬家打包场景：客厅 大件东西多，杂物多，打包工具：用到保鲜膜，胶带，气泡膜；打包原则：原样打包，同类叠着包，异形单独包再合并包。 如果有全屋装饰画，统一叠着，用保鲜膜包好，再用大胶带加固，用胶带粘了一个把手，搬运的时候方便提着。 置物架，拆掉方便搬运，减少磕碰损坏。拆掉部件统一用胶带缠好，螺丝零件用袋子包好，置物架部件+对应螺丝贴到一起，方便后续安装。 植物，形状也不规则，包装的时候最好是两个人配合，一个人先用气泡膜轻轻围住叶子部分，另一个人用细胶布缠绕，细胶带比较细，容易顺着植物的造型贴合贴紧，可以减少叶子的损害。 搬家前一个星期最好不要浇水，这样土不含水，轻，也好搬运。 电器类，有原包装的放回原包装。没有包装的包上气泡膜贴好，放到箱子里，箱子做重点标记。 书类，用行李箱装，结实，而且有轮子，方便拖。不过搬运师傅都是采用背的方式，有轮子对他们来说作用不是非常大。 全身镜，用了气泡膜认真包，易碎类马虎不得。 搬家打包场景：卧室 体积大重量轻的东西较多；打包工具：编织袋，黑色大垃圾袋；打包原则，原样打包，不怕碎统一装 衣服。 衣服架子，拆下来并到一起，保鲜膜包住，再贴紧。 这边就比较简单粗暴，是衣服连同衣架直接取下来，然后放到编织袋里去。到了新家就可以直接取出来挂上了。 包，用平时买衣服收到的布袋子装，防止刮花包表面，统一放编织袋提走了。包怕压，袋子上贴一个手写提醒师傅，装车的时候不要压这个。怕压变形可以放纸箱子。 鞋子，方法同包。 带抽屉的收纳柜，直接用保鲜膜裹紧，如果抽屉里比较空，可以先用纸团或者气泡膜塞一下再包。 棉被，压缩袋压缩，再装到黑色垃圾袋里。 玩偶，方法同棉被。 手帐用品，箱子装，箱子先垫防碎膜，手帐胶带和工具一起放，剪碎珍珠膜或者纸团塞缝隙再封口。 地毯，叠在一起放，最大张放下面，其他尺寸放上面，然后卷起来，用保鲜膜包住。记得正面对正面，背面贴背面。 一些不规则但是不太重的物品，先用保鲜膜包裹，再用用大胶带贴紧，同时贴出一些提手，方便搬运的时候提。 搬家打包场景：厕所 沐浴露洗衣液这类，新家旧家离得不远，是直接放到一个桶装完提上车就搞完了。 如果新家距离比较远，还是单独把按压口处理一下，缠保鲜膜，或者直接按压锁住，再做包装。 搬家前几日 提前确定新家和旧家楼下是否能停你叫的搬家车辆（不能停，可能会有路面费产生，一般超30米就会收） 找物业开好放行条 和师傅确定搬家细节（一般师傅会提前联系，真实说清楚，说少说小了，师傅现场要求加钱我们就被动了） 联系好来帮忙的朋友，找好请朋友吃饭的地方 搬家当天 全部清点物品数量，手机拍照+拍视频保存留底。 给师傅买好饮料 可能整个过程会发生小问题，保持平稳心态处理，加油加油 搬家公司选择 避雷点 不要找按小时计费的搬家公司，因为时间不受你控制，师傅大概率会拖沓 ，而且也拿他办法（可能是我们不会沟通）而且计时过程中，堵车等这类不受控情况，也是要算钱的。 最终确定搬家公司前，尽量问好详细的收费模式，多问清楚，有些隐藏收费不问他们不会主动说。 不要让搬家公司打包装，尽量自己包装好，搬家公司包装收费特别贵。 注意搬家货车的停车位置，这个也是最容易产生 额外 费用的点。定搬家公司前先去旧家和新家和物业确定，楼下能不能停车，最大能停多大的车，如果车停不下或者不能停，车停的距离如果大于30米，一般需要再次收路面费。 一口价的公司可能会对大件的家电（空调洗衣机这些）额外收费，具体可以先和师傅/客服沟通好。 最好是走搬家平台，出了问题相对好解决一些，平台约束。 搬家后归位","link":"/2022/02/19/%E6%90%AC%E5%AE%B6%E6%B8%85%E5%8D%95/"},{"title":"UIKit框架","text":"1.UIAcceleration: 被叫做加速事件的一个UIAcceleration类的实例是用来代表即时的三维加速数据。为了接收重力加速度，要注册一个应用应用程序作为一个共享UIAccelerater对象的委托对象（参考UIAcceleromete类）。 UIAccelerater:UIAccelerater类可以让你的寄存器接收到从板载硬件上得到的加速相关数据。当设备移动时，它的硬件能够报告沿主线在三维空间中的线性加速度变化。你可以利用这些数据来检测器件的电流方向和该方向的瞬时变化。你可以使用这瞬时变化输入到一个游戏或者启动应用程序中的一些行动。 UIaccessibilityElementUIAccessibilityElement类封装的项目信息对一些特殊的人可见，默认情况下是不可访问的。例如，一个图标或文字图像不会自动访问，因为它没有继承的UIView（或UIControl）。一个包含等非视图的项目，创建一个实例来表示每个项目需要访问的UIAccessibilityElement。 4.UIBarItem UIBarItem是一个抽象的超类用来在屏幕的底部给项目加上一栏。带栏的条目类似于一个按钮的方式。他们有标题，有图片，动作和目标。你可以在项目中启用和禁用一个带栏条目。 （1）UIBarButtonItem 一个栏按钮项目是放置在一个UIToolbar或UINavigation对象专门的按钮。它从它的抽象父类，UIBarItem继承的基本按钮的行为。UIBarButtonItem定义额外的初始化方法和属性，使用工具栏和导航栏。 （2）UITabBarItem UITabBarItem类实现了一个带标签栏的项目，UITabBar类的实例。一个标签栏严格地以收音机模式来运作，其中一个项目是在选定的时间，点击标签栏项目切换上面的标签栏。您还可以指定在标签栏上项目的信息，例如加入额外的视觉徽章值，电话应用程序上使用该项目的徽章，以显示新邮件的数量。这个类还提供了一些系统默认创建的项目。 5.UIBezierPath UIBezierPath类，您可以定义一个路径由直线和曲线的线段组成，并呈现在您的自定义视图路径。您可以使用这个类，最初只是为您的路径中指定的几何形状。路径可以定义简单的形状，如矩形，椭圆形和圆弧，或他们可以定义 杂的多边形，采用直线和曲线线段的混合物。定义的形状后，您可以使用这个类的其他方法来呈现当前图形上下文的路径。 6.UIColor 一个UIColor对象代表的颜色，有时不透明（alpha值）。您可以使用UIColor对象来存储颜色数据，并在绘画过程中，你可以用它们来设置当前填充和笔触颜色。 7.UIDecive UIDevice类提供了一个单个实例代表当前设备。从这个实例中，可以获取有关设备的唯一的ID，分配名称，设备型号，和操作系统名称和版本等信息。您也可以使用的UIDevice实例，检测设备的特点，如物理方向的变化。使用方向属性得到当前的方向，或注册UIDeviceOrientationDidChangeNotification通知收到更改通知。在使用这些技术来获得定位数据之前，你必须使数据传递，使用的beginGeneratingDeviceOrientationNotifications方法。当您不再需要跟踪设备的方向，调用endGeneratingDeviceOrientationNotifications方法来禁用交付的通知.. 8.UIDocumentInteractionController 一个文件交互控制器一起委托对象，提供应用程序管理与本地系统中的文件的用户交互的支持。例如，一个电子邮件程序可能使用这个类，允许用户预览附件和其他应用程序中打开它们。使用这个类，目前预览相应的用户界面，打开，复制或打印指定的文件。 9.UIEvent 一个UIEvent对象（或者简单地说，一个事件对象）代表在IOS的事件。一般有三种类型的事件：触摸事件，运动事件和远程控制的事件，。远程控制的事件使一个Responder对象来接收来自外部的附件或耳机的命令，以便它可以管理管理音频和视频，例如，播放视频或跳过到下一音轨。 10.UIFont UIFont类提供了用于获取和设置字体信息的接口。类提供了访问字体的特点，还提供了访问，这是在布局过程中中使用的字体的字形信息系统。他们通过接受它们作为参数的方法，您可以使用字体对象。 11.UIGestureRecognizer UIGestureRecognizer是一个具体的手势识别类的抽象基类。一个手势识别对象（或简单地说，一个手势识别）中分离出来承认这种认识上的姿态和行动的逻辑。当这些对象之一承认一个共同的姿态，或者，在某些情况下，改变的姿态，它发送一个动作消息，每一个指定的目 物镜。以下胃具体的子类： （1）UITapGestureRecognizer 单个或多个塞子。指定数量的手指必须要承认的姿态，挖掘查看指定的次数。 （2）UIPinchGestureRecognizer 看起来捏的手势，涉及两个接触。当用户将两个手指，向对方的传统意义是缩小;当用户将两个手指从彼此远离，传统意义变焦。 （3）UIRotationGestureRecognizer 看起来轮换涉及两个触摸手势。当用户移动手指对面对方的圆周运动，基本的观点应该在相应的方向和速度旋转。 （4）UISwipeGestureRecognizer 看起来刷卡在一个或多个方向的手势。抨击是一个独立的姿态，因此，相关的操作的消息发送每个手势只有一次。 （5）UIPanGestureRecognizer 看起来平移（拖动）的手势。用户必须按查看上一个或更多的手指，而他们平移。实施这个手势识别动作方法的客户端可以要求它目前的翻译和手势的速度。 (6)UILongPressGestureRecognizer 看起来长按手势。用户必须按下一个或更多的手指行动讯息传送至少指定期限。此外，手指可能要承认的姿态移动唯一指定的距离;如果他们超越这个限制的姿态失败。 12.UIImage 一个UIImage对象是一个高层次的的方式来显示图像数据。您可以从文件中创建的图像，从石英图像中的物体，或从您收到的原始图像数据。UIImage的类还提供图像绘制到当前图形的上下文中，使用不同的混合模式和不透明度值的几种选择。 13.UILocalizedIndexedCollation UILocalizedIndexedCollation类方便为有部分指数的图表进行组织，整理，以及数据本地化。表视图的数据源，然后使用排序对象提供的输入节的标题和节索引标题的表视图。 14.UILocalNotification UILocalNotification实例表示，应用程序可以提交给它的用户在特定的日期和时间安排的通知。操作系统是负责在适当的时间提供通知;没有要运行发生的应用程序。虽然本地的通知类似，因为它们是用于显示警报，播放声音和徽章的应用程序图标，远程通知，它们是组成和本地传递，不需要与远程服务器连接。 15.UIMenuController 他单身UIMenuController实例介绍了菜单界面的剪切，复制，粘贴，选择，选择，和删除命令。 16.UINavigationItem UINavigationItem类封装了一个UINavigationBar对象的堆栈上推导航项目的信息。一个导航栏是用于控制导航层次的内容。一个UINavigationItem指定什么是导航栏上的显示，当它是顶部的项目，也代表它是如何时，后面的项目。 17.UINib UINib类的实例作为对象包装或容器，InterfaceBuilder的nib文件。一个UINib对象在内存中缓存的一个nib文件的内容，准 解档和实例。当您的应用程序需要实例化的nib文件的内容，它可以这样做，而不必从nib文件加载数据，从而提高性能。UINib对象可以自动释放该缓存笔尖数据免费为您的应用程序内存在低内存条件下，重新装载数据下一次你的应用程序实例笔尖。您的应用程序应该使用UINib对象时，它需要反复实例相同的笔尖数据。例如，如果您的表视图使用nib文件实例表视图细胞，缓存中UINib对象的笔尖可以提供显着的性能改善。 18.UIPasteboard UIPasteboard类允许应用程序共享应用程序内部或与其他应用程序使用的全系统或应用程序特定的黏贴板的数据。 19.UIPopoverController UIPopoverController类是用于管理在popover中内容的呈现。你使用popovers暂时地呈现目前信息暂时而且用一种不超过整个屏幕就像一个模态视图的方式。popover内容是你在一个特殊类型的窗口的现有内容上分层。popover仍然可见，直到用户水龙头以外的popover窗口或你明确驳回。Popover控制器为iPad等设备的提供使用仅限。尝试在其他设备结果出现异常时进行新的一个创建。 20.UIPrintFormatter UIPrintFormatter时打印格式化的抽象基类：展示了传统的可打印的内容对象可以跨页边界。由于打印格式化，打印系统，可以自动打印与打印格式化的内容相关联的类型。以下为UIPrintFormatter的子类： (1)UISimpleTextPrintFormatter UISimpleTextPrintFormatter类的实例进行布局打印纯文本，可能是多个页面。类允许您指定的印刷文字全球的字体，颜色，对齐线，和换行符的模式属性。 (2)UIMarkupTextPrintFormatter UIMarkupTextPrintFormatter类的实例展示了一个多页打印作业的HTML标记文本。 (3)UIViewPrintFormatter UIViewPrintFormatter类的一个实例，勾画出用于打印的视图绘制的内容。视图的内容可以跨越多个页面。 21.UIPrintInfo 一个UIPrintInfo对象封装了有关打印作业的信息，包括打印机标识，作业名称，输出类型（照片，正常，灰阶），方向（纵向或横向），和任何选定的双工模式，。打印系统打印时，使用此信息。 22.UIPrintInteractionController UIPrintInteractionController类的共享实例，提出了印刷的用户界面和管理的文件，图像和其他可打印的内容在iOS打印。UIPrintInteractionController是IOS中央印刷类。它的共享实例代表一个打印作业。打印作业，包括其印刷相关的信息和选项，如输出类型，作业名称，纸张大小和方向，要打印的内容。 23.UIPrintPageRenderer 一个UIPrintPageRenderer对象绘制要打印页的内容带或不带打印格式化.A页面的渲染就是UIPrintPageRenderer自定义子类的一个实例。当您撰写打印作业使用的UIPrintInteractionController共享实例，您指定的页面渲染到该实例的printPageRenderer属性。 24.UIPrintPaper UIPrintPaper类的一个实例封装使用的纸张尺寸，打印作业，并在其中的内容可以打印的矩形。 25.UIResponder UIResponder类定义了一个接口，应对和处理事件的对象。它是UIApplication，UIView和它的子类（包括UIWindow中）的超类。这些类的实例有时被称为作为响应者对象或简单地说，应答。 （1）UIApplication UiApplication类，提供了一个在iOS上运行的应用程序的控制和协调集中点。每个应用程序必须具有完全的UIApplication的一个实例（或子类UIApplication）。当一个应用程序启动时，UIApplicationMain函数被调用，在其他任务中，这个函数创建了一个单身的UIApplication对象。此后，您可以通过这个对象调用sharedApplication类方法。 （2）UIViewController UIViewController类提供iPhone应用程序的基本观点的管理模式。基本视图控制器类支持相关联的视图的演示，为管理模式视图提供支持，并支持在响应设备方向变化旋转的意见。象UINavigationController和UITabBarController的这样的子类，如提供管理复杂的层次结构视图控制器和视图的其他行为。 1）UITabBarController UITabBarController类实现了一个专门的视图控制器管理一个广播式的选择界面。不适用于这个类的子类。相反，您可以使用它的实例去呈现允许用户在不同的操作模式之间进行选择的接口。这个标签栏界面显示在窗口底部的制表符之间的不同模式从而用来显示模式的意见选择。 2）UITableViewController UITableViewController类创建一个控制器对象，管理表视图。 3）UINavigationController UINavigationController的类实现了一个专门的视图控制器管理层次的内容导航。不适用于这个类的子类。相反，您可以使用实例当你希望你的应用程序的用户界面能够反映您的内容的层次性。此导航界面使你更有效的展现数据而且更容易让用户浏览内容。 3－1）UIImagePickerController UIImagePickerController类管理定制的和系统提供的用户界面，支持的设备上的图片和电影，并选择把使用的图片和电影保存在您的应用程序中。的图像选取器控制器管理用户交互和委托对象提供这些相互作用的结果。 3－2）UIVideoEditorController 一个UIVideoEditorController对象，或视频编辑器，通过修剪从以前录制的电影的开始和结束的视频帧，以及重新编码降低质量来管理系统提供的用户界面。对象管理的用户交互，并提供您的委托对象编辑的电影文件系统路径。UIVideoEditorController类的特点是仅适用于设备，支持视频录制。 （3）UIView UIView类通过定义一个在屏幕和界面上的矩形区域来管理这块区域的内容。在运行时，视图对象处理其区域内的任何内容渲染，还处理与该内容的任何相互作用。UIView类本身提供了基本行为的背景颜色填充矩形区域。更加复杂的内容，可以通过继承UIView和实施必要的绘图和自身事件处理代码来展现。UIKit框架还包括一个 准的子类可以使用的范围从简单的按钮到复杂的表集。例如，一个UILabel对象绘制一个文本字符串和一个UIImageView对象绘制一个图像。 1）UIWindow UIWindow类定义，管理和协调的Windows应用程序显示在屏幕上的对象（如Windows）。一个窗口的两个主要职能是，为显示其意见面积和分发活动的意见。窗口是在视图层次的根。一个窗口属于一个级别；一个级别的窗口出现另一个层面以上。例如，警报出现高于正常的窗口。通常情况下，只有一个在IOS应用程序的窗口。 2）UILabel UILabel类实现一个只读的文本视图。您可以使用这个类的静态文本，如你可能会使用它来识别你的用户界面的其他部分，绘制一个或多个行。基本UILabel类提供控制文本的外观，包括它是否使用了一层阴影，或汲取的一大亮点。如果需要，您可以自定义文本的外观进一步通过继承。 3）UIPickerView UIPickerView类实现对象，所谓的选择器的看法，即使用一个纺车或老虎 机的比喻来显示一个或多个值集。用户可以选择旋转的车轮，使所需的行的值与选择的指 之间的对应关系值。UIDatePicker类使用一个自定义子类的UIPickerView显示日期和时间。为了看一个例子，挖掘在时钟应用程序报警窗格添加(“+”)按钮。 4）UIProgressView 当一个邮件应用程序下载消息时它的进度条会在应用程序的底部显示。UIProgressView类提供了管理风格的进度条，用于获取和设置值是固定的任务的进度的属性。 5）UIActivityIndicatorView UIActivityIndicatorView类创建和管理一个指标用来显示不确定的任务进度。从外观上看，这个指 是一个“齿轮”是动画旋转。 6）UIImageView 图像的视图对象提供了一个用于显示单个图像或者一系列动画图像的基于视图的容器。对于动画图像，UIImageView的类提供设置动画的持续时间和频率的控制。您还可以启动和停止动画自由。 7）UITabBar UITabBar类实现了一个选择两个或多个按钮的控制，并称之为项目。一个标签栏最常见的用途是实现一个模态接口攻一个项目的变化选择。如果你想暂时突出或不会改变某个项目的外观时，轻按按钮，使用一个UIToolbar对象。UITabBar类提供为用户定制能力重新排列标签栏，删除和酒吧中添加项目。您可以使用标签栏的委托，以增加这种行为。 8）UIToolBar 一个工具栏是显示一个或多个按钮被称之为工具栏项一种控制。当被轻按时工具栏瞬间突出或不改变某个项目的外观。 9）UINavigationBar UINavigationBar类实现了一个层次的内容导航控制。它的一个条形栏，通常显示在屏幕上方，包含用于导航的向上和向下一个层次的按钮。主要属性是左（后退）按钮，中心的名称和一个可选的右边的按钮。您可以指定这些自定义视图。 10）UITableViewCell 的UITableViewCell类定义的细胞出现在UITableView的对象的属性和行为中。 11）UIActionSheet 使用UIActionSheet类可以把一套如何继续给定任务的替代品给用户。您还可以使用行动表，以提示用户确认是否有潜在危险的行动。该行动表包含一个可选的标题和一个或多个按钮，其中每个对应采取的行动。 12）UIAlterView 使用UIAlertView类向用户显示一条警告消息。警报视图的功能相似，但在外观上不同于一个动作表（UIActionSheet的一个实例）。 13）UIScrollView UIScrollView的类提供支持显示的内容是大于应用程序的窗口大小。它可以使用户内滚动的内容，通过刷卡手势，和捏的手势放大和部分内容。 13－1）UITextView UITextView的类实现一个滚动的，多行文本区域的行为。类支持使用自定义字体，颜色，和对齐的文本的显示，同时还支持文本编辑。通常可以使用一个文本视图，显示多行文本，如显示一个大的文本文件的身体时，。 13－2）UITableView 的UITableView（或简单地说，表视图）的一个实例是用于显示和编辑分层列出的信息的一种手段。 14）UISearchBar UISearchBar类实现一个基于文本的搜索的文本字段控制。该控件提供了一个搜索按钮，输入文字的文本字段书签“按钮，一个取消按钮。UISearchBar对象实际上并不执行任何搜索。您可以使用委托，符合UISearchBarDelegate协议的对象，实施行动时，输入文本和按钮被点击。 15）UIWebView 您使用了UIWebView类，在您的应用程序中嵌入网页内容。要做到这一点，你只需创建一个UIWebView对象，将它附加到一个窗口，它发送一个请求加载网页内容。您也可以使用这个类在网页的历史向前和向后移动，你甚至可以设置一些网页内容属性的编程。 16）UIControl UIControl是为控制对象，如用户的意图传达到应用程序的按钮和滑块的基类。你不能直接使用UIControl类实例化控制。相反，它定义了共同的界面和它的所有子类的行为结构。 16－1）UIButton UIButton的类的一个实例，实现了在触摸屏上的按钮。触摸一个按钮拦截事件和动作消息发送到目标对象时。设定的目 和行动方法都继承自UIControl。这个类提供了方法来设置标题，图像，按钮等外观属性。通过这些访问，您可以为每个按钮状态指定一个不同的外观。 16－2）UIDatePicker UIDatePicker类实现了一个对象，它使用多个旋转的车轮，以允许用户选择日期和时间。iPhone的例子是一个日期选择器，定时器和闹钟设置闹钟的时钟应用程序中的窗格。您也可以使用日期选择器作为一个倒数计时器。 16－3）UIPageControl 您可以使用UIPageControl类来创建和管理页面控制。一个页面控制是在控制中心的点继承。每个点对应一个应用程序的文档（或其他实体的数据模型）页面，白色圆点表示当前浏览的网页。 16－4）UISegmentedControl 一个UISegmentedControl对象是横向控制多个段，每个段作为一个独立的按钮运作。分段控制提供一个紧凑的手段，组合到一起的控制。 16－5）UITextField UITextField对象是一个显示可编辑的文字和动作消息发送到目标对象，当用户按下返回按钮控制。通常可以使用这个类从用户收集少量的文字，并执行一些立即采取行动，如搜索操作，根据该文本。 16－6）UISlider 一个UISlider对象是一个可视化的控制，用来选择一个连续值范围从单一的值。滑块始终显示为单杠。指 ，或拇指，注意到滑块的当前值，并更改设置的用户可以通过移动。 16－7）UISwitch 您可以使用UISwitch类来创建和管理ON/ OFF按钮，您会看到，例如在飞行模式等服务的偏好设定（设定）。这些对象被称为开关。 26.UIScreen 一个UIScreen对象包含设备的整个屏幕的边界矩形。当设置应用程序的用户界面，你应该使用这个对象的属性，能为您的应用程序的窗口的建议的框架矩形。 27.UIScreenMode 一个UIScreenMode对象表示的，可以应用到一个UIScreen对象的属性可能。该对象封装了有关屏幕的底层显示缓冲区的大小和使用单个像素的宽高比信息。 28.UISearchDisplayController 搜索显示控制器管理一个搜索栏，显示表视图显示另一种观点认为控制器管理的数据搜索的结果。 29.UITextChecker 您使用的UITextChecker类的实例来检查拼写错误的单词字符串（通常是文档中的文本）。 30.UITextPosition 一个UITextPosition对象代表一个文本容器中的位置，换句话说，它是一个到在文本显示的支持字符串的索引。 31.UITextRange 一个UITextRange对象代表一个字符在文本容器的范围，换句话说，它确定一个起始索引和结束索引一个字符串，支持一个文本输入对象。 32.UITouch 一个UITouch对象表示存在一个特定事件的屏幕上用手指或运动。你可以通过UIEvent对象传递到事件处理响应对象UITouch对象。","link":"/2022/03/07/UIKit%E6%A1%86%E6%9E%B6/"},{"title":"LLVM","text":"LLVM 是模块化、可重用的编译器以及工具链技术的集合。 不同的前端后端使用统一的中间代码 LLVM IR 优点：支持一种新的编程语言，只需要实现一个新的前端。支持一种新的硬件设备，只需要实现一个新的后端。 GCC的前后端联系紧密，耦合在一起。 LLVM 作为实现各种静态和运行时编译语言的通用基础结构。 Clang 是 LLVM 的子项目，属于前端。 相对于 GCC，编译快、内存小、模块化设计、诊断信息可读性强。 源代码 –&gt; 前端 –&gt; 优化器 –&gt; 后端 –&gt; 机器码 前端： 词法分词、语法分析、语义分析、生成中间代码 优化器： 中间代码优化 后端： 生成机器码","link":"/2022/03/10/LLVM/"},{"title":"Xcode快捷键","text":"常用的快捷键 光标左移：ctrl+b光标右移：ctrl+f光标上移：ctrl+p光标下移：ctrl+n光标移至一行最左边：ctrl+a删除快捷键：ctrl+k 光标移至一行最右边：ctrl+e删除一个单词：option+delete缩进对齐：ctrl+i向右边删除：ctrl+d向上移动：ctrl+u向下移动：ctrl+v呼出搜索行数：command+l","link":"/2022/03/16/Xcode%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"title":"《光刻巨人》读书笔记","text":"[TOC] ASML 的诞生芯片，也叫集成电路，是半导体元件产品的统称。光刻机是制造芯片的关键设备。把光通过集成电路版图投影到晶圆上。晶圆再经过切割、封装、测试等工序后就成为芯片。 阿斯麦的光刻技术来源于荷兰科技巨头飞利浦公司。上世纪 60 年代初飞利浦物理实验室研制出了一种6镜头重复曝光光刻机。但光刻机并没有得到当时飞利浦高层的重视。 考虑到光刻机的研发成本很高，市场前景也不明朗，在 1983 年的一次董事会上，董事们否决了继续开发光刻机的计划，决定把这项业务剥离出去。 飞利浦和ASM合资成立一家光刻机公司。1984 年 4 月 1 日愚人节这天，合资公司正式成立了。这就是后来的光刻机巨头阿斯麦公司。 创业的艰难阿斯麦的战略目标和定位斯密特提出，阿斯麦的目标是必须成为行业第一。在半导体行业，有一个著名的摩尔定律，意思是，每两年，集成电路的晶体管数量会翻一番。 光刻机市场是个小众市场，一台机器又能用很多年。这导致一旦机器落后一点，就没人愿意买了。技术领先是夺取市场的关键。这就形成赢者通吃的行业规律。 所以，只要公司能开发出符合未来市场需求的产品，就有机会成为行业领导者。 阿斯麦的战略定位管理层给公司的定位是：只做组装和产品设计，自己不生产任何部件。 它的好处在于：首先，刚成立的阿斯麦，资金和人员都非常匮乏。公司要成为行业第一，就必须集中有限资源做最核心的业务。 其次，它让阿斯麦能够整合全球的尖端技术，把产品做到极致。 阿斯麦的技术研发斯密特决定，在 1985 和 1986 年各推出一款新机器。 在这么短的时间里做出新产品，对工程师来说是前所未有的挑战。这就需要打破传统的研发模式。为此，工程师们想出了一个方案，把机器拆分成 5 个模块，由不同的技术团队并行开发各个模块，最后，再把模块组装成系统。对机器的测试也是如此。阿斯麦构建了5个原型机，这样，测试和组装只需要半年。 在阿斯麦，每个人都像上了发条的机器。工程师们经常加班到深夜，甚至通宵达旦的工作。最后，这两款机器都以创纪录的速度如期制造完成，而且产品性能完全达到预期标准。 阿斯麦怎样筹集资金光刻机有个绰号叫“吞金巨兽”。开发光刻机的材料和人工成本都非常高。 公司主要的资金来源是银行贷款、融资租赁、政府的贷款和补贴，其中，最主要的是荷兰政府的贷款和补贴。 阿斯麦的股东 ASM 公司已经撑不下去了。为了不被阿斯麦拖垮，它于 1988 年把股份卖给飞利浦后，黯然离场。 除了政府资金的扶持，飞利浦也给了阿斯麦公司很大的支持。 阿斯麦的营销策略公司专门在美国的凤凰城成立了营销团队。在团队的组建上，阿斯麦公司采用本土化的方式，聘用了经验丰富的美国销售人员。并给他们充分的权利，让他们自己制定销售政策。 在 1985 年的美国半导体展会上，阿斯麦把展位设在展馆中心最昂贵的区域，紧挨着尼康和佳能这样的行业巨头。阿斯麦还准备了设计精美的广告宣传册。 借助这次展会的宣传效果，营销团队成功的把几台光刻机卖给了一家叫MMI的小芯片制造商。 经过4年的艰苦创业，阿斯麦终于在强敌环伺的市场中生存了下来，并为以后的发展打下了牢固的基础。 阿斯麦是如何成为行业巨头的从80年代末到90年代中这段时间，阿斯麦开发了一款叫 PAS5500 的机器，并获得了很大成功。阿斯麦由此成为了行业三巨头之一。 公司的技术攻关公司的管理层决定再开发一款更先进的机器。它的整体性能必须超过尼康和佳能的产品。这款机器被命名为 PAS5500。 接下来，公司的整体战略都将围绕 PAS5500 展开。它的成功与否将决定公司未来的命运。现在，公司又回到刚创立时的起点：在创纪录的时间里制造一台全新的机器。工程师们又投入到忘我的工作中。 阿斯麦的营销创新阿斯麦在销售 PAS5500 时，推出了“不赚钱不付款”的支付方式，和“拥有价值”的概念。 “不赚钱不付款”的意思是，客户先支付机器售价的 80%，根据最终的业绩再支付其余的费用。 PAS5500 的价格比竞争对手的机器平均要贵 25%，但它有更高的精度、分辨率和吞吐量。这意味着芯片厂商的生产成本更低，效率更高。简而言之，用阿斯麦的光刻机可以获得更高的利润。阿斯麦当时的CEO马里斯把这称作“拥有价值”，也就是，客户使用阿斯麦的光刻机能够创造更多的价值。 阿斯麦的产业协作阿斯麦光刻机的镜头则来自德国的顶尖镜头制造商蔡司。 蔡司的镜头是由经验丰富的工匠手工制作。但是，这种传统的工艺已无法满足半导体行业对镜头越来越严格的要求了。 在阿斯麦的帮助下，蔡司回到了行业中的领先位置。同时，阿斯麦也彻底解决了 PAS5500 的镜头质量问题。凭借这款机器优异的性能，阿斯麦跨入了光刻机一线厂商的行列。 后续阿斯麦超越尼康，始于技术突破：2004 年开发出了著名的浸没式光刻机和极紫外光刻","link":"/2022/03/19/%E3%80%8A%E5%85%89%E5%88%BB%E5%B7%A8%E4%BA%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"小知识","slug":"小知识","link":"/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"},{"name":"Swift语言","slug":"Swift语言","link":"/tags/Swift%E8%AF%AD%E8%A8%80/"},{"name":"技术","slug":"技术","link":"/tags/%E6%8A%80%E6%9C%AF/"},{"name":"建站","slug":"建站","link":"/tags/%E5%BB%BA%E7%AB%99/"},{"name":"学习记录","slug":"学习记录","link":"/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"面试题","slug":"面试题","link":"/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"搬家","slug":"搬家","link":"/tags/%E6%90%AC%E5%AE%B6/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"读书笔记","slug":"读书笔记","link":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"categories":[]}