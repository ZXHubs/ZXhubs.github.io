{"pages":[{"title":"","text":"Hi 我是 ZhangX","link":"/about/index.html"}],"posts":[{"title":"Hello World","text":"欢迎👏来到这。","link":"/2022/02/19/hello-world/"},{"title":"Swift 笔记","text":"swift 笔记基础介绍常量let &amp; 变量var1234let a = 10 // 常量的值设定后不能更改var b = 0var x = 0.0, y = 0.0, z = 0.0var red, green, blue: Double // 理论上可以实际很少这么写 常量和变量名可以包含任何字符，包括一些Unicode字符。常量和变量名不能包含空格，数学符号，箭头，专用的Unicode标量值或线条和框形图字符，不能以数字开头。不能将常量更改为变量或将变量更改为常量。如果需要命名为保留的Swift关键字名称，在关键字两端加上反引号`，不建议使用保留的关键字。 使用 \\() 打印 1print(&quot;a = \\(num))&quot;) 注释123// 单行注释/* 多行注释可以嵌套 */ 分号可以写也可以不写，一般不写分号。如果要在一行上编写多个单独的语句，则需要分号。 整数Swift提供8位，16位，32位和64位形式的有符号和无符号整数。其中8位无符号整数的类型为UInt8，而32位有符号整数的类型为Int32。一般使用Int就可以了。 12let minValue = UInt8.min // 0let maxValue = UInt8.max // 255 在大多数情况下，无需选择特定大小的整数即可在代码中使用。Swift提供了额外的整数类型，Int其大小与当前平台的本机字大小相同：在32位平台上，Int与大小相同Int32；在64位平台上，Int与大小相同Int64。Swift还提供了一个无符号整数类型，UInt其大小与当前平台的本机字大小相同。 浮点值 Double 表示一个64位浮点数，精度至少为15个十进制数字 Float 表示一个32位浮点数，精度可以低至6个十进制数字类型推断当声明具有初始值的常量或变量时，swift根据类型推断来确定常量或者变量的类型：var name: String在浮点值里面默认都是Double数字1234let a = 17 // 十进制数，无前缀let b = 0b10001 // 二进制数，前缀0blet c = 0o21 // 八进制数，前缀0olet d = 0x11 // 十六进制数，前缀0x 浮点文字可以是十进制（不带前缀）或十六进制（带0x前缀）。它们的小数点两侧必须始终有一个数字（或十六进制数字）。小数浮点数也可以有一个可选的指数，用大写或小写表示e; 十六进制浮点数必须具有指数，以大写或小写表示p。对于指数为的十进制数字exp，基数乘以10^exp： 1.25e2表示1.25 x 10^2，或125.0。 1.25e-2表示1.25 x 10^-2，或0.0125。 对于指数为的十六进制数exp，将基数乘以2^exp： 0xFp2表示15 x 2^2，或60.0。 0xFp-2表示15 x 2^-2，或3.75。 123let decimal = 12.1875 // 十进制let e = 1.21875e1 // 指数let hexadecimal = 0xC.3p0 // 十六进制 数值类型转换123let twoThousand: UInt16 = 2_000let one: UInt8 = 1let twoThousandAndOne = twoThousand + UInt16(one) 类型别名类型别名为现有类型定义备用名称，可以使用typealias关键字定义类型别名。想通过上下文更合适的名称来引用现有类型时，例如使用外部源中特定大小的数据时，类型别名非常有用： 1typealias AudioSample = UInt16 定义类型别名后，可以在任何可能使用原始名称的地方使用别名： 12var maxAmplitudeFound = AudioSample.min 布尔值 Booltrue 和 false 数组 Tuples数组将多个值分组为一个复合值。数组中的值可以是任何类型，而不必彼此相同。如果请求的网页不存在，则返回状态404 Not Found 1let http404Error = (404, &quot;Not Found&quot;) 可以将数组的内容分解为单独的常量或变量，然后像往常一样访问它们： 12345let (statusCode, statusMessage) = http404Errorprint(&quot;The status code is \\(statusCode)&quot;)print(&quot;The status message is \\(statusMessage)&quot;) 如果只需要一些数组的值，则在分解数组时，请用下划线_忽略该数组的某些部分： 123let (justTheStatusCode, _) = http404Errorprint(&quot;The status code is \\(justTheStatusCode)&quot;) 或者，使用从零开始的索引号访问数组中的各个元素值： 1234print(&quot;The status code is \\(http404Error.0)&quot;)print(&quot;The status message is \\(http404Error.1)&quot;) 定义数组时，可以命名数组中的各个元素： 1let http200Status = (statusCode: 200, description: &quot;OK&quot;) 如果在数组中命名元素，则可以使用元素名称来访问这些元素的值： 1234print(&quot;The status code is \\(http200Status.statusCode)&quot;)// Prints &quot;The status code is 200&quot;print(&quot;The status message is \\(http200Status.description)&quot;)// Prints &quot;The status message is OK&quot; 具有多个返回值的函数使用数组特别合适。数组对于简单的一组相关值很有用。它们不适合创建复杂的数据结构。如果数据结构可能更复杂，则将其建模为类或结构，而不是数组。 OptionalsOptionals 表示要么有一个值并且可访问该值，或者为nil。以下示例使用初始化程序尝试将 String转换为Int，由于初始化程序可能失败，因此它返回一个optional Int而不是一个Int。 123let possibleNumber = &quot;123&quot;let convertedNumber = Int(possibleNumber) 如果定义一个可选变量而不提供默认值，则该变量将自动nil设置为： 123var surveyAnswer: String?surveyAnswer = nil // 也可以给optional赋值为nil 1. 可选值的强制展开一旦确定可选选项确实包含一个值，就可以在可选名称的末尾添加一个感叹号!来访问其基础值。 123if convertedNumber != nil { print(&quot;convertedNumber has an integer value of \\(convertedNumber!).&quot;)} 2. Optional 可选 12345678910if let constantName = someOptional { statements}if let actualNumber = Int(possibleNumber) { print(&quot;The string \\&quot;\\(possibleNumber)\\&quot; has an integer value of \\(actualNumber)&quot;)} else { print(&quot;The string \\&quot;\\(possibleNumber)\\&quot; could not be converted to an integer&quot;)} 字符串Strings多行字符串文字用三引号 “””两个”””之间的字符串都作为多行字符串的值，如果仅想在代码里换行是代码易读，可以在换行符前添加反斜杠转义 转义字符串\\0（空字符）\\（反斜杠）\\t（水平制表符）\\n（换行符）\\r（回车）&quot;（双引号）'（单引号）任意的Unicode标值，写为\\u{n}，其中n是一个1-8位十六进制数 1234567891011let wiseWords = &quot;\\&quot;Imagination is more important than knowledge\\&quot; - Einstein&quot;let dollarSign = &quot;\\u{24}&quot; // $, Unicode scalar U+0024let blackHeart = &quot;\\u{2665}&quot; // ♥, Unicode scalar U+2665let sparklingHeart = &quot;\\u{1F496}&quot; // 💖, Unicode scalar U+1F496//因为多行字符串文字使用三个双引号而不是一个双引号，可以在多行字符串文字中包含一个双引号而不进行转义。let threeDoubleQuotationMarks = &quot;&quot;&quot;Escaping the first quotation mark \\&quot;&quot;&quot;Escaping all three quotation marks \\&quot;\\&quot;\\&quot;&quot;&quot;&quot; 初始化字符串123var emptyString = &quot;&quot; // 空var anotherEmptyString = String() // 初始化 访问和修改String1234567891011121314151617181920let greeting = &quot;Guten Tag!&quot;greeting[greeting.startIndex]// Ggreeting[greeting.index(before: greeting.endIndex)]// !greeting[greeting.index(after: greeting.startIndex)]// ulet index = greeting.index(greeting.startIndex, offsetBy: 7)greeting[index]// agreeting[greeting.endIndex] // Errorgreeting.index(after: greeting.endIndex) // Errorfor index in greeting.indices { print(&quot;\\(greeting[index]) &quot;, terminator: &quot;&quot;)} 子串12345let greeting = &quot;Hello, world!&quot;let index = greeting.firstIndex(of: &quot;,&quot;) ?? greeting.endIndexlet beginning = greeting[..&lt;index]let newString = String(beginning) greeting是一个字符串，具有一个存储区域，用于存储组成该字符串的字符。因为beginning是的子字符串greeting，所以它重复使用了所greeting使用的内存。相反，newString是一个字符串-从子字符串创建它时，它具有自己的存储空间。准备长时间存储结果时，可以将子字符串转换为字符串 比较字符串可以用 == 或者 != 12345let str = &quot;HelloWorld&quot;let str1 = &quot;HelloWorld&quot;if str == str1 { print(&quot;相等&quot;)} 集合三种collection： array有序集合, set唯一值的无序集合, dictionary键-值对关联的无序集合。 Array1234567891011var arr = Array&lt;Int&gt; // 空数组，两种方式，一般采用[]var someInts = [Int]() // 简写someInts.append(3) someInts = [] var threeDoubles = Array(repeating: 0.0, count: 3)var anotherThreeDoubles = Array(repeating: 2.5, count: 3)var sixDoubles = threeDoubles + anotherThreeDoubles 增删改查 12345678910111213141516171819202122232425262728293031323334353637383940var shoppingList: [String] = [&quot;Eggs&quot;, &quot;Milk&quot;]var shoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;] // 类型推断print(&quot;The shopping list contains \\(shoppingList.count) items.&quot;)if shoppingList.isEmpty { print(&quot;The shopping list is empty.&quot;)} else { print(&quot;The shopping list is not empty.&quot;)}shoppingList.append(&quot;Flour&quot;)shoppingList += [&quot;Baking Powder&quot;]shoppingList += [&quot;Chocolate Spread&quot;, &quot;Cheese&quot;, &quot;Butter&quot;]var firstItem = shoppingList[0]shoppingList[0] = &quot;Six eggs&quot;shoppingList[4...6] = [&quot;Bananas&quot;, &quot;Apples&quot;]// 将索引[4,6]的元素换成[&quot;Bananas&quot;, &quot;Apples&quot;] // insert和remove操作后，其他元素顺移shoppingList.insert(&quot;Maple Syrup&quot;, at: 0)// 索引0位置插入为&quot;Maple Syrup&quot;let mapleSyrup = shoppingList.remove(at: 0)// 删除索引0位置的元素，并且返回该位置元素的值let apples = shoppingList.removeLast() //避免查询.count检查是否越界for item in shoppingList { print(item)}for (index, value) in shoppingList.enumerated() { print(&quot;Item \\(index + 1): \\(value)&quot;)} Set类型必须是可哈希的才能存储在Set中 123var letters = Set&lt;Character&gt;() // Set没有简写letters.insert(&quot;a&quot;) letters = [] 增删改查 12345678910111213141516171819202122232425262728293031323334353637383940var favoriteGenres: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]var favoriteGenres: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;] //类型推断print(&quot;I have \\(favoriteGenres.count) favorite music genres.&quot;)if favoriteGenres.isEmpty { print(&quot;As far as music goes, I'm not picky.&quot;)} else { print(&quot;I have particular music preferences.&quot;)}favoriteGenres.insert(&quot;Jazz&quot;)// .removeAll()删除全部元素if let removedGenre = favoriteGenres.remove(&quot;Rock&quot;) { print(&quot;\\(removedGenre)? I'm over it.&quot;)} else { print(&quot;I never much cared for that.&quot;)}if favoriteGenres.contains(&quot;Funk&quot;) { print(&quot;I get up on the good foot.&quot;)} else { print(&quot;It's too funky in here.&quot;)}for genre in favoriteGenres { print(&quot;\\(genre)&quot;)}for genre in favoriteGenres.sorted() { // 按&lt;的顺序返回 print(&quot;\\(genre)&quot;)} intersection(_:)方法创建仅具有两个集合共有的值的新集合。 symmetricDifference(_:)方法创建一个新集合，其中两个集合中都有一个值，但不能同时包含两个集合中的值。 union(_:)方法创建一个包含两个集合中所有值的新集合。 subtracting(_:)方法创建一个新集合，其值不在指定集合中。 ==确定两组是否包含所有相同的值。 isSubset(of:)方法确定集合中的所有值是否都包含在指定集合中。 isSuperset(of:)方法确定集合是否包含指定集合中的所有值。 isStrictSubset(of:)或isStrictSuperset(of:)方法确定集合是子集还是超集，但不等于指定的集合。 isDisjoint(with:)方法确定两个集合是否没有共同的值。 Dictionary字典Key类型必须符合Hashable协议 1234567var dic = Dictionary&lt;Key, Value&gt;var namesOfIntegers = [Int: String]() // 简写namesOfIntegers[16] = &quot;sixteen&quot;namesOfIntegers = [:] 增删改查 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var airports: [String: String] = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]var airports = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]// 当key和value是同一类型的时候，swift可以进行类型推断print(&quot;The airports dictionary contains \\(airports.count) items.&quot;)if airports.isEmpty { print(&quot;The airports dictionary is empty.&quot;)} else { print(&quot;The airports dictionary is not empty.&quot;)}airports[&quot;LHR&quot;] = &quot;London&quot;airports[&quot;LHR&quot;] = &quot;London Heathrow&quot;if let oldValue = airports.updateValue(&quot;Dublin Airport&quot;, forKey: &quot;DUB&quot;) { print(&quot;The old value for DUB was \\(oldValue).&quot;)}// updateValue(_:forKey:)方法返回字典值类型的可选值。if let airportName = airports[&quot;DUB&quot;] { print(&quot;The name of the airport is \\(airportName).&quot;)} else { print(&quot;That airport is not in the airports dictionary.&quot;)}airports[&quot;APL&quot;] = &quot;Apple International&quot;airports[&quot;APL&quot;] = nilif let removedValue = airports.removeValue(forKey: &quot;DUB&quot;) { print(&quot;The removed airport's name is \\(removedValue).&quot;)} else { print(&quot;The airports dictionary does not contain a value for DUB.&quot;)}for (airportCode, airportName) in airports { print(&quot;\\(airportCode): \\(airportName)&quot;)}for airportCode in airports.keys { print(&quot;Airport code: \\(airportCode)&quot;)}for airportName in airports.values { print(&quot;Airport name: \\(airportName)&quot;)} Swift的Dictionary类型没有定义的顺序。要以特定顺序遍历字典的键或值，可以在keys或values属性上使用sorted()。 控制流for in 循环1234567891011for index in 1...5 { print(&quot;\\(index) times 5 is \\(index * 5)&quot;)}// index是一个常数无需声明let base = 3let power = 10var answer = 1for _ in 1...power { answer *= base}// 如果不需要索引值，怎可以使用 下划线_ 代替 123456789101112131415let minutes = 60for tickMark in 0..&lt;minutes {}let minuteInterval = 5for tickMark in stride(from: 0, to: minutes, by: minuteInterval) { }let hours = 12let hourInterval = 3for tickMark in stride(from: 3, through: hours, by: hourInterval) { } While 循环 while 每次循环执行时都会评估其条件。 repeat- while在每次循环结束时评估其条件。在考虑循环条件之前，会先执行一次循环循环。然后，它将继续重复循环，直到条件为false。类似于 do - while 1234567while condition { statements}repeat { statements} while condition 条件语句if多个判断条件可以用逗号连接 switchbreak在Swift中不是必需的，但是可以使用break语句来匹配和忽略特定的情况，或者在该情况完成执行之前中断匹配的情况。每个case都必须包含一个可执行语句，一个case两种value用逗号隔开 123456789101112131415161718192021222324252627282930switch some value to consider {case value 1: respond to value 1case value 2, value 3: respond to value 2 or 3default: otherwise, do something else}//间隔匹配let approximateCount = 62let countedThings = &quot;moons orbiting Saturn&quot;let naturalCount: Stringswitch approximateCount {case 0: naturalCount = &quot;no&quot;case 1..&lt;5: naturalCount = &quot;a few&quot;case 5..&lt;12: naturalCount = &quot;several&quot;case 12..&lt;100: naturalCount = &quot;dozens of&quot;case 100..&lt;1000: naturalCount = &quot;hundreds of&quot;default: naturalCount = &quot;many&quot;}print(&quot;There are \\(naturalCount) \\(countedThings).&quot;) 1234567891011121314let somePoint = (1, 1)switch somePoint {case (0, 0): print(&quot;\\(somePoint) is at the origin&quot;)case (_, 0): print(&quot;\\(somePoint) is on the x-axis&quot;)case (0, _): print(&quot;\\(somePoint) is on the y-axis&quot;)case (-2...2, -2...2): print(&quot;\\(somePoint) is inside the box&quot;)default: print(&quot;\\(somePoint) is outside of the box&quot;)} (0，0）可以匹配所有四种情况。但是，如果可能有多个匹配项，则始终使用第一个匹配情况，所有其他匹配情况都将被忽略。 函数Function只用return一行编写的任何函数都可以省略return。 123456789101112131415161718// 没有参数func sayHelloWorld() -&gt; String { return &quot;hello, world&quot;}// 多个参数func greet(person: String, alreadyGreeted: Bool) -&gt; String { if alreadyGreeted { return greetAgain(person: person) } else { return greet(person: person) }}// 没有返回值func greet(person: String) { print(&quot;Hello, \\(person)!&quot;)} 12345678910func printAndCount(string: String) -&gt; Int { print(string) return string.count}func printWithoutCounting(string: String) { let _ = printAndCount(string: string)}printAndCount(string: &quot;hello, world&quot;)printWithoutCounting(string: &quot;hello, world&quot;) 第一个函数printAndCount(string:)打印一个字符串，然后将其字符计数返回为Int。第二个函数printWithoutCounting(string:)调用第一个函数，但忽略其返回值。当调用第二个函数时，第一个函数仍会打印该消息，但是不使用返回的值。 具有多个返回值的函数可以使用数组类型作为函数的返回类型，以将多个值作为一个复合返回值的一部分返回。 123456789101112131415func minMax(array: [Int]) -&gt; (min: Int, max: Int) { var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] { if value &lt; currentMin { currentMin = value } else if value &gt; currentMax { currentMax = value } } return (currentMin, currentMax)}let bounds = minMax(array: [8, -6, 2, 109, 3, 71])print(&quot;min is \\(bounds.min) and max is \\(bounds.max)&quot;) 在从函数返回数组时不必命名数组的成员，因为它们的名称已作为函数返回类型的一部分指定。 返回Optional123456789101112131415161718func minMax(array: [Int]) -&gt; (min: Int, max: Int)? { if array.isEmpty { return nil } var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] { if value &lt; currentMin { currentMin = value } else if value &gt; currentMax { currentMax = value } } return (currentMin, currentMax)}if let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) { print(&quot;min is \\(bounds.min) and max is \\(bounds.max)&quot;)} 函数类型由函数的参数类型和返回类型组成，如(Int, Int) -&gt; Int 1234// () -&gt; Voidfunc printHelloWorld() { print(&quot;hello, world&quot;)} 使用函数类型可以将常量或变量定义为函数类型，然后为该变量分配适当的函数： 1var mathFunction: (Int, Int) -&gt; Int = addTwoInts “定义一个名为mathFunction的变量，其类型为一个具有两个Int值并返回Int值的函数。” 设置这个变量来表示函数addTwoInts。” 1234print(&quot;Result: \\(mathFunction(2, 3))&quot;) // Prints &quot;Result: 5&quot;let anotherMathFunction = addTwoInts // 类型推断 Function Types作为另一个函数的参数类型12345func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) { print(&quot;Result: \\(mathFunction(a, b))&quot;)}printMathResult(addTwoInts, 3, 5) 定义了一个名为printMathResult(::_:)的函数，该函数具有三个参数。第一个参数名为mathFunction，类型为(Int, Int) -&gt; Int。第二个和第三个参数分别名为a和b，并且均为type Int。 Function Types作为返回类型123456789101112131415161718192021func stepForward(_ input: Int) -&gt; Int { return input + 1}func stepBackward(_ input: Int) -&gt; Int { return input - 1}func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int { return backward ? stepBackward : stepForward}var currentValue = 3let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)print(&quot;Counting to zero:&quot;)while currentValue != 0 { print(&quot;\\(currentValue)... &quot;) currentValue = moveNearerToZero(currentValue)}print(&quot;zero!&quot;) 嵌套函数12345678910111213func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int { func stepForward(input: Int) -&gt; Int { return input + 1 } func stepBackward(input: Int) -&gt; Int { return input - 1 } return backward ? stepBackward : stepForward}var currentValue = -4let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)while currentValue != 0 { print(&quot;\\(currentValue)... &quot;) currentValue = moveNearerToZero(currentValue)}print(&quot;zero!&quot;) 枚举语法1234567891011121314151617181920enum CompassPoint { case north case south case east case west}var directionToHead = CompassPoint.westdirectionToHead = .east // 类型推断directionToHead = .southswitch directionToHead {case .north: print(&quot;Lots of planets have a north&quot;)case .south: print(&quot;Watch out for penguins&quot;)case .east: print(&quot;Where the sun rises&quot;)case .west: print(&quot;Where the skies are blue&quot;)} 遍历枚举1234567891011enum Beverage: CaseIterable { case coffee, tea, juice}let numberOfChoices = Beverage.allCases.countprint(&quot;\\(numberOfChoices) beverages available&quot;)for beverage in Beverage.allCases { print(beverage)} 结构体和类Swift不需要为自定义结构和类创建单独的接口和实现文件，可以在单个文件中定义结构或类，并且该类或结构的外部接口会自动提供给其他代码使用。 struct和class的共同点和区别class具有struct没有的其他功能： 继承使一个类可以继承另一个类的特征。 通过类型转换，可以在运行时检查和解释类实例的类型。 反初始化程序使类的实例可以释放其已分配的所有资源。 引用计数允许对一个类实例进行多个引用。 12345678910111213141516171819202122232425struct Resolution { var width = 0 var height = 0}class VideoMode { var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String?}// 创建实例（对象）let someResolution = Resolution()let someVideoMode = VideoMode()// 访问属性print(&quot;The width of someResolution is \\(someResolution.width)&quot;)print(&quot;The width of someVideoMode is \\(someVideoMode.resolution.width)&quot;)someVideoMode.resolution.width = 1280print(&quot;The width of someVideoMode is now \\(someVideoMode.resolution.width)&quot;)// struct具有Initializers，class需要initlet vga = Resolution(width: 640, height: 480) struct和enum是值类型Swift中的所有基本类型（整数，浮点数，布尔值，字符串，数组和字典）都是值类型，所有结struct和enum都是值类型。。 class是引用类型与值类型不同，将引用类型分配给var或let或将其传递给函数时，不会复制引用类型，而是都是同一个实例的引用。 可以通过 === 或者 !== 比较两个是否引用相同的实例 === 表示var或者let都引用同一个实例，而==表示两个实例的值相等 123if tenEighty === alsoTenEighty { print(&quot;tenEighty and alsoTenEighty refer to the same VideoMode instance.&quot;)}","link":"/2022/02/19/swift/"},{"title":"咖啡","text":"咖啡的小知识原材料：咖啡从树上结果，生的状态一般叫绿咖啡Green coffee咖啡两大类：Arabica阿拉比卡和Robusta罗布斯塔。前者比后者更优质咖啡因的含量和风味不同。一般Robusta豆的咖啡因比Arabica豆要高。Robusta主要产地是东半球越南、非洲。Arabica糖和脂多主要产地牙买加、夏威夷。品牌：蓝山、曼特宁、科纳。咖啡树热带植物煮的咖啡brewed coffeelight/blonde轻度烘焙；medium中度烘焙；dark roast重度烘焙酸涩感：轻度&gt;中度&gt;重度冲煮专业名词都为萃取浸泡式brewed意式浓缩espresso【可以搭配奶、巧克力酱】拿铁、摩卡、卡布奇诺","link":"/2022/02/19/%E5%92%96%E5%95%A1/"},{"title":"搭建博客","text":"利用 Hexo + GitHub(Gitee) Pages 搭建个人博客序 文章从两个部分介绍 Hexo 和 GitHub Pages 结合，快速、便捷的搭建出博客，且无流量限制，属于自己的个人博客。续写你自己的技术、感受等任何类型的文章。 GitHub(Gitee) Pages步骤一、如果没有 GitHub 或 Gitee 账户先注册一个。然后新建一个仓库。在 GitHub 下仓库名要求格式：xxx.github.io 的形式。步骤二、勾选 README。步骤三、点击 Create repository。 对于 Gitee 来说，仓库必须有 index.html 才可以正常访问。步骤一、新建一个仓库。步骤二、新建一个文件 index.html 提交到仓库步骤三、选择 “服务 - Pages 服务”（注意使用必须要求实名认证否则无法使用，不想实名认证建议使用 GitHub）步骤四、选择部署分支点击启动。 Hexo https://hexo.io/zh-cn/ 这是 Hexo 中文官方网站https://git-scm.com 这是 Git 官方网站https://nodejs.org/zh-cn/ 这是 Node.js 官方网站 步骤一、在本地创建一个存放博客的文件夹。步骤二、确保本机已经安装好了 Node.js 和 Git。步骤三、通过终端（Mac）或 Windows 下的命令行工具执行下列命令安装 Hexo。不要复制 $ 符号。假设文件夹在桌面上名为：zxhusb。 12$ cd /Desktop/zxhubs$ npm install -g hexo-cli 步骤四、在zxhubs文件夹目录下执行，如果没有执行 cd zxhusb。 123$ hexo init zxhusb$ npm install$ hexo server 步骤五、打开浏览器输入 localhost:4000 即可看到对应 Hexo 的默认 landscape 主题。如果对默认的不满意，（绝大多数人都会修改主题）在 Hexo 主题 中找到自己喜欢的主题。如果需要关闭本地服务器在命令行直接按 control + C 即可关闭。步骤六、更换主题，在 zxhubs 的目录下执行，下面命令是举例说明。 1$ git clone https://github.com/probberechts/cactus-dark 在 zxhubs 编辑 _config.yml，修改 theme，为主题的名字。 12theme: cactus-dark 步骤七、上传到 GitHub 或 Gitee 上，继续编辑 _config.yml。 123456deploy: type: git repository: # 此处改为你自己GitHub Pages 或者 Gitee Pages 地址 branch:main #注意以前用的 GitHub 已将 master 改成了 mian，对于 Gitee 还是 master 这样大家都可以在网上浏览了你的网页了。步骤八、添加或修改博客的内容 1hexo new 此处替换为你的文章名字支持中英文 步骤九、完成文章的撰写后，执行下列命令，生成静态网页。 1hexo g 步骤十、上传到网页上执行 1hexo deploy 这样即可在网页中看到修改的内容了，如果不想使用 xxx.github.io或xxx.gitee.io的域名，可以自己去备案购买申请一个域名，修改为自己的域名。 跋 希望上述教程能够协助大家完成自己博客的搭建，这将会是一件有趣事情。能够提高你自己的动手能力和解决问题的能力，在搭建和写作过程中遇到的问题可以慢慢探索。","link":"/2022/02/20/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"title":"如何运行 GitHub 上的 iOS app","text":"步骤一、clone 源码之后，在你的 Mac 上安装 CocoaPods。 步骤二、打开 终端，切换到工程文件的目录下。比如你的工程文件下载到了 Mac 的桌面上，在 终端 app 中输入 cd 切换到文件目录下。 步骤三、输入 pod install 安装工程所依赖的库。显示如下即安装成功。步骤四、在 Xcode 中打开运行本工程文件，请注意⚠️打开的是 .xcworkspace 并非是 .xcodeproj，请务必注意后缀。 在上述指南中可能会遇到的一些疑惑。 Q：CocoaPods 是什么？A：CocoaPods 是 macOS 和 iOS 平台非常流行的包管理工具，用来帮助我们管理第三方依赖库的工具。通过调用第三方库，可以用于拓展软件的功能。 Q：为什么需要 CocoaPods？A：在实际开发过程中避免不了去使用第三方的库，所以会使用到 CocoaPods。pod 是由 ruby 语言编写的，是记录引用库的名称，执行 pod install 即在把远程仓库下载至本地。 Q：在使用 pod install 命令时速度过慢？A：解决方案之一可以采取换源的方式。输入 gem sources 能够查看当前源。输入 gem sources --add https://gems.ruby-china.com/ 删除之前的源 gem sources -r https://rubygems.org/ Q：在使用 Podfile 文件是什么？A：用于描述一个或多个 Xcode Project 中各个 Targets 之间的依赖关系 Q：在使用 Lockfile 文件是什么？A：用于记录最后一次 CocoaPods 所安装的 Pod 依赖库版本的信息快照。生成的 Podfile.lock。在 pod install 过程，Podfile 会结合它来确认最终所安装的 Pod 版本。 Q：xcworkspace 和 xcodeproj 的区别？A：xcodeproj bundle 内包含 project.workspace。而当我们通过 pod install 命令添加 Pod 依赖后，Xcode 工程目录下会多出 .workspace，它是 Xcodeproj 替我们生成的，用于管理当前的 .project 与 Pods.pbxproj。","link":"/2022/02/22/%E5%A6%82%E4%BD%95%E8%B7%91GitHub%E4%B8%8A%E7%9A%84iOSapp/"},{"title":"设计模式 MVC 和 MVVM","text":"MVCM 是数据模型 Model，负责处理数据，以及数据改变时发出通知。（Notification、KVO），Model 和 View 不能直接进行通信，这样会违背 MVC 设计模式。 V 是视图 View，用来展示界面，和用户进行交互，为了解耦合一般不会直接持有或者操作数据层中的数据模型（可以通过 target-action、delegate、block 等方式解耦）。 C 是控制器 Controller 用来调节 Model 和 View 之间的交互，可以直接与 Model 还有 View 进行通信，操作 Model 进行数据更新，刷新 View。 MVC如图所示 优点：View、Model 低耦合、高复用、容易维护。缺点：Controller 的代码过于臃肿，如果 View 与 Model 直接交互会导致 View 和 Model 之间的耦合性增大，网络逻辑会加重 Controller 的臃肿。 MVVMMVVM 衍生于 MVC，是 MVC 的一种演进，促进了 UI 代码和业务逻辑的分离，抽取 Controller 中的展示逻辑放到 ViewModel 中。 M：数据模型 Model，负责处理数据，以及数据改变时发出通知。 V：是 View 和 Controller 联系到一起，视为一个组件 View。View 和 Controller 都不直接引用模型 Model，可以引用视图模型 ViewModel。ViewController 尽量不涉及业务逻辑，让 ViewModel 做这些事情。ViewController 属于中间人，负责接收 View 的事件、调用 ViewModel 的方法、响应 ViewModel 的变化。 VM：ViewModel 负责封装业务逻辑、网络处理和数据缓存。使用 ViewModel 会轻微增加代码量，但是总体上减少了代码的复杂性。ViewModel 之间可以有依赖。 注意事项：View 引用 ViewModel，但是反过来不行，因为如果 VM 跟 V 产生了耦合，不方便复用。即不要在 ViewModel 中引用 UIKit，任何视图本身的引用都不应该放在 ViewModel 中。ViewModel 可以引用 Model，但反过来不行。 优点：低耦合、可复用、数据流向清晰，而且兼容 MVC，便于代码的移植，并且 ViewModel 可以拆除来独立开发方便测试。缺点：类会增多，ViewModel 会越来越庞大，调用复杂度增加、双向绑定数据会导致问题调试变得困难。 总结MVVM 其实是 MVC 的变种。MVVM 只是帮 MVC 中的 Controller 瘦身，把一些逻辑代码和网络请求分离出去。不让 Controller 处理更多的东西，不会变得臃肿，MVVM 和 MVC 可以根据实际需求进行灵活选择。 MVVM 在使用当中，通常还会利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。OC中可以用 RAC 函数响应式框架来实现响应式编程。","link":"/2022/02/23/MVC%E5%92%8CMVVM/"},{"title":"iOS 面试题","text":"TCP 为什么要三次握手，四次挥手？为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误，假设这是一个早已失效的报文段。 但是服务器使用到此失效的连接请求报文段后，就误认为客户端再次发出的一个新的连接请求。于是就向客户端发出确认报文段，同意建立连接。 假设不采用三次握手，那么只要服务器发出确认，新的连接就建立了。 由于客户端没有发出建立连接的请求，因此不会理睬服务器的确认，也不会向服务器发送数据，但是服务器却以为新的运输连接已经建立，并一直等待客户端发来数据，这样服务器的很多资源就会被浪费掉。 四次挥手主要是：因为 TCP 是全双工通信，在接收到客户端的关闭请求时，还可能在向客户端发送数据，因此不能回应关闭链接的请求时，同时发送关闭链接的请求。 HTTP 和 HTTPS 的区别HTTP 是明文传输，数据都是为加密的，安全性较差。HTTPS（SSL+HTTP）数据传输过程是加密的，安全性较高。 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构）申请证书，一般免费证书少，因而需要一定费用。 HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS 除了 TCP 的三个包，还要加上 SSL 握手需要的 9 个包，一共是 12 个包。 HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443. HTTPS 就是建构在 SSL/TLS 之上的 HTTP 协议，所以，HTTPS 比 HTTP 更加消耗服务器资源。 成员变量和属性的区别以及不同关键字的作用成员变量：默认修饰符是 protected，不会自动生成 set 和 get 方法，需要手动实现，不能使用点语法调用，因为没有 set 和get 方法，只能使用-&gt;。 属性：默认会生成带下划线的成员变量和 setter/getter 方法，可以使用点语法调用，实际上调用的是 set 和 get 方法。⚠️注意：分类中添加的属性是不会自动生成 setter/getter 方法，必须手动添加。 实例变量：class 类进行实例化出来的对象为实例对象。 关键字作用：public 声明公共实例变量，在任何地方都能直接访问对象的成员变量。private 声明私有实例变量，只能在当前类对象方法中直接访问，子类要访问需要调用父类的 set/get方法。 private(set)。protected 可以在当前类及其子类对象方法中直接访问（系统默认）。package 在同一个包下就可以直接访问，诸如同一个框架下。property 声明属性","link":"/2022/02/23/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"小知识","slug":"小知识","link":"/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"},{"name":"Swift语言","slug":"Swift语言","link":"/tags/Swift%E8%AF%AD%E8%A8%80/"},{"name":"技术","slug":"技术","link":"/tags/%E6%8A%80%E6%9C%AF/"},{"name":"建站","slug":"建站","link":"/tags/%E5%BB%BA%E7%AB%99/"},{"name":"学习记录","slug":"学习记录","link":"/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"面试题","slug":"面试题","link":"/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"categories":[]}